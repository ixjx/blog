<p><a href="http://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">有限状态机</a>（Finite-state machine）是一个非常有用的模型，可以模拟世界上大部分事物。</p>

<p><img src="http://image.beekka.com/blog/201309/bg2013090201.png" alt="" /></p>

<p>简单说，它有三个特征：</p>
<blockquote>
  <ul>
    <li>
      <p>状态总数（state）是有限的。</p>
    </li>
    <li>
      <p>任一时刻，只处在一种状态之中。</p>
    </li>
    <li>
      <p>某种条件下，会从一种状态转变（transition）到另一种状态。
它对JavaScript的意义在于，很多对象可以写成有限状态机。</p>
    </li>
  </ul>
</blockquote>

<!--more-->

<p>举例来说，网页上有一个菜单元素。鼠标悬停的时候，菜单显示；鼠标移开的时候，菜单隐藏。如果使用有限状态机描述，就是这个菜单只有两种状态（显示和隐藏），鼠标会引发状态转变。</p>

<p>代码可以写成下面这样：</p>
<pre class="brush:javascript">var menu = {

　　　　// 当前状态
　　　　currentState: &#39;hide&#39;,

　　　　// 绑定事件
　　　　initialize: function() {
　　　　　　var self = this;
　　　　　　self.on(&quot;hover&quot;, self.transition);
　　　　},

　　　　// 状态转换
　　　　transition: function(event){
　　　　　　switch(this.currentState) {
　　　　　　　　case &quot;hide&quot;:
　　　　　　　　　　this.currentState = &#39;show&#39;;
　　　　　　　　　　doSomething();
　　　　　　　　　　break;
　　　　　　　　case &quot;show&quot;:
　　　　　　　　　　this.currentState = &#39;hide&#39;;
　　　　　　　　　　doSomething();
　　　　　　　　　　break;
　　　　　　　　default:
　　　　　　　　　　console.log(&#39;Invalid State!&#39;);
　　　　　　　　　　break;
　　　　　　}
　　　　}

　　};
　　</pre>
<p>可以看到，有限状态机的写法，逻辑清晰，表达力强，有利于封装事件。一个对象的状态越多、发生的事件越多，就越适合采用有限状态机的写法。</p>

<p>另外，JavaScript语言是一种<a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html">异步操作</a>特别多的语言，常用的解决方法是指定回调函数，但这样会造成代码结构混乱、难以测试和除错等问题。有限状态机提供了<a href="http://tech.pro/blog/1402/five-patterns-to-help-you-tame-asynchronous-javascript">更好的办法</a>：把异步操作与对象的状态改变挂钩，当异步操作结束的时候，发生相应的状态改变，由此再触发其他操作。这要比回调函数、事件监听、发布/订阅等解决方案，在逻辑上更合理，更易于降低代码的复杂度。</p>

<p>下面介绍一个有限状态机的函数库<a href="https://github.com/jakesgordon/javascript-state-machine">Javascript Finite State Machine</a>。这个库非常好懂，可以帮助我们加深理解，而且功能一点都不弱。</p>

<p>该库提供一个全局对象StateMachine，使用该对象的create方法，可以生成有限状态机的实例。
` 　　var fsm = StateMachine.create(); 　　 `
生成的时候，需要提供一个参数对象，用来描述实例的性质。比如，交通信号灯（红绿灯）可以这样描述：</p>
<pre class="brush:javascript">　var fsm = StateMachine.create({

　　　　initial: &#39;green&#39;,

　　　　events: [
　　　　　　{ name: &#39;warn&#39;,  from: &#39;green&#39;,  to: &#39;yellow&#39; },
　　　　　　{ name: &#39;stop&#39;, from: &#39;yellow&#39;, to: &#39;red&#39; },
　　　　　　{ name: &#39;ready&#39;,  from: &#39;red&#39;,    to: &#39;yellow&#39; },
　　　　　　{ name: &#39;go&#39;, from: &#39;yellow&#39;, to: &#39;green&#39; }
　　　　]

　　});</pre>
<p>交通信号灯的初始状态（initial）为green，events属性是触发状态改变的各种事件，比如warn事件使得green状态变成yellow状态，stop事件使得yellow状态变成red状态等等。</p>

<p>生成实例以后，就可以随时查询当前状态。</p>
<blockquote>
  <ul>
    <li>
      <p>fsm.current ：返回当前状态。</p>
    </li>
    <li>
      <p>fsm.is(s) ：返回一个布尔值，表示状态s是否为当前状态。</p>
    </li>
    <li>
      <p>fsm.can(e) ：返回一个布尔值，表示事件e是否能在当前状态触发。</p>
    </li>
    <li>fsm.cannot(e) ：返回一个布尔值，表示事件e是否不能在当前状态触发。
Javascript Finite State Machine允许为每个事件指定两个回调函数，以warn事件为例：</li>
    <li>
      <p>onbeforewarn：在warn事件发生之前触发。</p>
    </li>
    <li>onafterwarn（可简写成onwarn） ：在warn事件发生之后触发。
同时，它也允许为每个状态指定两个回调函数，以green状态为例：</li>
    <li>
      <p>onleavegreen ：在离开green状态时触发。</p>
    </li>
    <li>onentergreen（可简写成ongreen） ：在进入green状态时触发。
假定warn事件使得状态从green变为yellow，上面四类回调函数的发生顺序如下：onbeforewarn → onleavegreen → onenteryellow → onafterwarn。</li>
  </ul>
</blockquote>

<p>除了为每个事件和状态单独指定回调函数，还可以为所有的事件和状态指定通用的回调函数。</p>
<blockquote>
  <ul>
    <li>
      <p>onbeforeevent ：任一事件发生之前触发。</p>
    </li>
    <li>
      <p>onleavestate ：离开任一状态时触发。</p>
    </li>
    <li>
      <p>onenterstate ：进入任一状态时触发。</p>
    </li>
    <li>
      <p>onafterevent ：任一事件结束后触发。
如果事件的回调函数里面有异步操作（比如与服务器进行Ajax通信），这时我们可能希望等到异步操作结束，再发生状态改变。这就要用到transition方法。</p>
    </li>
  </ul>
</blockquote>
<pre class="brush:javascript">　fsm.onleavegreen = function(){
　　　　light.fadeOut(&#39;slow&#39;, function() {
　　　　　　fsm.transition();
　　　　});
　　　　return StateMachine.ASYNC;
　　};</pre>
<p>上面代码的回调函数里面，有一个异步操作（light.fadeOut）。如果不希望状态立即改变，就要让回调函数返回StateMachine.ASYNC，表示状态暂时不改变；等到异步操作结束，再调用transition方法，使得状态发生改变。</p>

<p>Javascript Finite State Machine还允许指定错误处理函数，当发生了当前状态不可能发生的事件时自动触发。</p>
<pre class="brush:javascript">var fsm = StateMachine.create({
　　　　// ...
　　　　error: function(eventName, from, to, args, errorCode, errorMessage) {
　　　　　　return &#39;event &#39; + eventName + &#39;: &#39; + errorMessage;
　　　　},
　　　　// ... 
　　});</pre>
<p>比如，当前状态是green，理论上这时只可能发生warn事件。要是这时发生了stop事件，就会触发上面的错误处理函数。</p>

<p>Javascript Finite State Machine的基本用法就是上面这些，更详细的介绍可以参见它的<a href="https://github.com/jakesgordon/javascript-state-machine">主页</a>。</p>

<p>（完）</p>
<div>

### 文档信息

*   版权声明：自由转载-非商用-非衍生-保持署名 | [Creative Commons BY-NC-ND 3.0](http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh)
*   原文网址：[http://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html](http://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html)
*   最后修改时间：2013年9月 4日 10:55
*   付费支持：[![人民币 - 支付宝](http://www.ruanyifeng.com/blog/images/rmb_32.png "人民币")](https://me.alipay.com/ruanyf) | [![美元 - paypal](http://www.ruanyifeng.com/blog/images/dollar_32.png "美元")](https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=yifeng.ruan@gmail.com&amp;currency_code=USD&amp;amount=0.99&amp;return=http://www.ruanyifeng.com/thank.html&amp;item_name=Ruan%20YiFeng)
</div>
