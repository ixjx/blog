<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CodeShurrik</title>
    <description>shurrik`s blog</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 15 May 2018 11:51:58 +0800</pubDate>
    <lastBuildDate>Tue, 15 May 2018 11:51:58 +0800</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>碎碎念</title>
        <description>&lt;p&gt;　　最近开始使用Firefox，我相信用惯了Chrome/360急速的人看着最上面标签条十分辣眼睛，找了个插件&lt;a href=&quot;https://addons.mozilla.org/zh-CN/firefox/user/nanpuyue/&quot;&gt;https://addons.mozilla.org/zh-CN/firefox/user/nanpuyue/&lt;/a&gt;需要安装一个脚本，然而我这里的网络打不开gist。。。不过另外３个插件最小化最大化和关闭键倒是用上了&lt;/p&gt;

&lt;p&gt;　　参考了&lt;a href=&quot;http://eleveni386.7axu.com/blog/post/admin/Linux%E7%94%A8%E6%88%B7%E5%8E%BB%E6%8E%89Firefox-57-%E8%AE%A8%E5%8E%8C%E7%9A%84Title-bar&quot;&gt;http://eleveni386.7axu.com/blog/post/admin/Linux%E7%94%A8%E6%88%B7%E5%8E%BB%E6%8E%89Firefox-57-%E8%AE%A8%E5%8E%8C%E7%9A%84Title-bar&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;　思路&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　利用wmctrl找到窗口ID , 使用GDK得到该窗口句柄, 并操作窗口. 去掉窗口装饰器(外边框)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;准备工具&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　需要wmctrl, 以及pygtk包&lt;/p&gt;

&lt;p&gt;　　这两个需要自行安装, 一般发行版本 不自带&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;操作步骤&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;重命名firefox
&lt;code class=&quot;highlighter-rouge&quot;&gt;mv /usr/lib/firefox/firefox /usr/lib/firefox/firefox-browser&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;创建同名脚本vi firefox
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
/usr/lib/firefox/firefox-browser &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; &amp;amp;
&lt;span class=&quot;nb&quot;&gt;sleep &lt;/span&gt;2
&lt;span class=&quot;nv&quot;&gt;F_W_ID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;wmctrl &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; |grep &lt;span class=&quot;s1&quot;&gt;'Firefox'&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;'{print $1}'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
python &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'from gtk.gdk import window_foreign_new, window_process_all_updates; w = window_foreign_new(int(&quot;'&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$F_W_ID&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&quot;, 16)); w.set_decorations(0); window_process_all_updates()'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;给予执行权限
&lt;code class=&quot;highlighter-rouge&quot;&gt;chomd 777 firefox&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;完毕, 截图
&lt;img src=&quot;http://shurriklab.qiniudn.com/20180326170147.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 15 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018-05-15/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/2018-05-15/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</guid>
        
        <category>负能量</category>
        
        
        <category>水</category>
        
      </item>
    
      <item>
        <title>干掉Linux Firefox的Title bar</title>
        <description>&lt;p&gt;　　最近开始使用Firefox，我相信用惯了Chrome/360急速的人看着最上面标签条十分辣眼睛，找了个插件&lt;a href=&quot;https://addons.mozilla.org/zh-CN/firefox/user/nanpuyue/&quot;&gt;https://addons.mozilla.org/zh-CN/firefox/user/nanpuyue/&lt;/a&gt;需要安装一个脚本，然而我这里的网络打不开gist。。。不过另外３个插件最小化最大化和关闭键倒是用上了&lt;/p&gt;

&lt;p&gt;　　参考了&lt;a href=&quot;http://eleveni386.7axu.com/blog/post/admin/Linux%E7%94%A8%E6%88%B7%E5%8E%BB%E6%8E%89Firefox-57-%E8%AE%A8%E5%8E%8C%E7%9A%84Title-bar&quot;&gt;http://eleveni386.7axu.com/blog/post/admin/Linux%E7%94%A8%E6%88%B7%E5%8E%BB%E6%8E%89Firefox-57-%E8%AE%A8%E5%8E%8C%E7%9A%84Title-bar&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;　思路&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　利用wmctrl找到窗口ID , 使用GDK得到该窗口句柄, 并操作窗口. 去掉窗口装饰器(外边框)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;准备工具&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　需要wmctrl, 以及pygtk包&lt;/p&gt;

&lt;p&gt;　　这两个需要自行安装, 一般发行版本 不自带&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;操作步骤&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;重命名firefox
&lt;code class=&quot;highlighter-rouge&quot;&gt;mv /usr/lib/firefox/firefox /usr/lib/firefox/firefox-browser&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;创建同名脚本vi firefox
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
/usr/lib/firefox/firefox-browser &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; &amp;amp;
&lt;span class=&quot;nb&quot;&gt;sleep &lt;/span&gt;2
&lt;span class=&quot;nv&quot;&gt;F_W_ID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;wmctrl &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; |grep &lt;span class=&quot;s1&quot;&gt;'Firefox'&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;'{print $1}'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
python &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'from gtk.gdk import window_foreign_new, window_process_all_updates; w = window_foreign_new(int(&quot;'&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$F_W_ID&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&quot;, 16)); w.set_decorations(0); window_process_all_updates()'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;给予执行权限
&lt;code class=&quot;highlighter-rouge&quot;&gt;chomd 777 firefox&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;完毕, 截图
&lt;img src=&quot;http://shurriklab.qiniudn.com/20180326170147.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 26 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018-03-26/%E5%B9%B2%E6%8E%89Linux-Firefox%E7%9A%84Title-bar/</link>
        <guid isPermaLink="true">http://localhost:4000/2018-03-26/%E5%B9%B2%E6%8E%89Linux-Firefox%E7%9A%84Title-bar/</guid>
        
        <category>Linux</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>制作网站docker镜像</title>
        <description>&lt;p&gt;　　看docker官方文档的时候，官网总被墙，怎么办呢？&lt;/p&gt;

&lt;p&gt;　　首先 &lt;em&gt;感谢&lt;/em&gt; 伟大的墙及其先祖。&lt;/p&gt;

&lt;p&gt;　　然后，我们可以本地运行 Docker 官方文档的网站，以 docker 的方式：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ docker run -d -p 80:4000 docs/docker.github.io&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　这样访问docker宿主机的 80 端口，如&lt;a href=&quot;http://localhost&quot;&gt;http://localhost&lt;/a&gt;，就会看到官网文档了。&lt;/p&gt;

&lt;p&gt;　　最近有朋友说我的blog被墙了打不开，我大惊，定睛一看发现是github pages改成了https，也就是说网址要改成&lt;a href=&quot;https://ixjx.github.io/blog&quot;&gt;https://ixjx.github.io/blog&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;　　想到同样可以用docker的方式来本地运行网站，说干就干。依然是利用docker cloud的automated build，在blog的github里写Dockerfile，Dockerfile很简单，一共就5行~~&lt;/p&gt;

&lt;p&gt;　　因为使用了caddy作为web服务器，同时还要写一个Caddyfile。&lt;/p&gt;

&lt;p&gt;　　然后就可以通过:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ docker run -d -p 80:80 ixjx/ixjx.github.io&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　然后就可以访问本地 80 端口看到最新的blog了 &lt;del&gt;说得好像有人看一样&lt;/del&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018-03-01/%E5%88%B6%E4%BD%9C%E7%BD%91%E7%AB%99docker%E9%95%9C%E5%83%8F/</link>
        <guid isPermaLink="true">http://localhost:4000/2018-03-01/%E5%88%B6%E4%BD%9C%E7%BD%91%E7%AB%99docker%E9%95%9C%E5%83%8F/</guid>
        
        <category>容器</category>
        
        
        <category>网络</category>
        
      </item>
    
      <item>
        <title>使用docker科学上网</title>
        <description>&lt;p&gt;　　之前写过一篇&lt;a href=&quot;http://ixjx.github.io/blog/2015-06-05/%E7%A7%91%E5%AD%A6%E5%A7%BF%E5%8A%BF%E4%B8%8Agoogle%E6%8C%87%E5%8C%97/&quot;&gt;科学上网指北&lt;/a&gt;，学习使用docker后配合食用更佳~&lt;/p&gt;

&lt;p&gt;　　首先当然是要安装好docker，这里不细说。其实也没什么好扯的，直接上科学上网方法吧。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;PPTP&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　自己写的一个PPTP的镜像，VPS里直接执行&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d --privileged --net=host ixjx/vpn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就可以食用。&lt;/p&gt;

&lt;p&gt;　　在github上写&lt;a href=&quot;https://github.com/ixjx/docker-vpn&quot;&gt;Dockerfile&lt;/a&gt;，在docker hub上关联github帐号就可以直接生成镜像，这一点docker支持做得不错。&lt;/p&gt;

&lt;p&gt;　　这样你的pptp vpn就设置好了，默认用户名密码是username/password。接下来就在自己的客户端上连接吧。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;L2TP/IPSec&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　之前iOS和MacOS升级，导致PPTP VPN已经不能使用了，需要用L2TP/IPSec来代替：&lt;/p&gt;

&lt;p&gt;　　先把Docker容器拉下来：&lt;/p&gt;

&lt;p&gt;　　&lt;code class=&quot;highlighter-rouge&quot;&gt;docker pull hwdsl2/ipsec-vpn-server&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　然后创建vpn.env文件，在文件中写入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;VPN_IPSEC_PSK=&amp;lt;IPsec pre-shared key&amp;gt;
VPN_USER=&amp;lt;VPN Username&amp;gt;
VPN_PASSWORD=&amp;lt;VPN Password&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　上面的内容分别是秘钥，用户名，密码，随便设置，到时候填入客户端的时候填同样的值就行了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo modprobe af_key
docker run \
    --name ipsec-vpn-server \
    --env-file ./vpn.env \
    -p 500:500/udp \
    -p 4500:4500/udp \
    -v /lib/modules:/lib/modules:ro \
    -d --privileged \
    --restart=always \
    hwdsl2/ipsec-vpn-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shadowsocks&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　大名鼎鼎的SS。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d -p 1984:1984 oddrationale/docker-shadowsocks -s 0.0.0.0 -p 1984 -k PASSWORD -m aes-256-cfb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　只需要把上面的PASSWORD换成你自己的密码就可以了，注意，上面创建的shadowsocks端口为1984， 加密方式为aes-256-cfb，在客户端设置时要设置成相同的值。&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018-01-16/%E4%BD%BF%E7%94%A8docker%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2018-01-16/%E4%BD%BF%E7%94%A8docker%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</guid>
        
        <category>翻墙</category>
        
        
        <category>网络</category>
        
      </item>
    
      <item>
        <title>2017年终总结</title>
        <description>&lt;p&gt;　　”年”只是我们划分人生的一种刻度，所以无须到年底，才知道自己这一年过得怎么样。但仪式感还是要有的，不是写给别人看，而是给自己，习惯了每到年底都做一个总结，似乎不写下什么就没有跟年初的自己握手言和。现在看前几年的年终总结，能看到成长的痕迹，感觉很有趣。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://ixjx.github.io/blog/2014-01-14/2013%E8%83%A1%E4%B9%B1%E6%80%BB%E7%BB%93/&quot;&gt;2013胡乱总结&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://ixjx.github.io/blog/2014-12-30/2014%E5%B8%9D%E9%83%BD%E6%B8%B8/&quot;&gt;2014帝都游&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://ixjx.github.io/blog/2015-12-19/2015%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/&quot;&gt;2015年终总结&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://ixjx.github.io/blog/2016-12-21/%E5%8A%A0%E9%80%9F%E4%B8%96%E7%95%8C/&quot;&gt;加速世界（2016年终总结）&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就像我的about里写的一样:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;主要用途是记录自己的生活和与之相关的一些心得体会，转载一些技术文章，然后到若干年后自己回顾一下，看看当时的自己是多么幼稚，仅此而已。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　年轻的时候很容易做出突破性的成就，年纪大一点也许就是在之前的基础上去迭代。不要不服，25岁能第一次结婚，30岁最多只能生个娃。25岁能买第一套房，30岁只能换更大的房。25岁能买第一辆车，30岁最多换个路虎……我的意思是，无法获得质的提升。&lt;/p&gt;

&lt;p&gt;　　但有量的提升已经很好，我们不能像小时候一样横冲直撞，妄想在所有的方向上有所成就。
　　&lt;/p&gt;

&lt;p&gt;　　26岁的自己，虽然没有做出惊天动地的事情，但我知道他在努力变得比25岁的自己更好。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;今年2月份去了三亚，10月去了山西，11月还去了普吉。普吉因为是跟团游，比较坑爹，前两天玩玩玩，剩下的就是带你去购物消费，体验很糟糕。以后能自由行还是自由行吧。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;7月份到了新的部门，目前负责了一个WIFI解决方案项目（也许现在才能叫”负责”这个词，之前用”支持”更准确），后续的优化，需要考虑和完善的工作还有很多。Stay hungry, Stay foolish.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关注了一个&lt;a href=&quot;http://www.cnblogs.com/CloudMan6/p/5224114.html&quot;&gt;每天5分钟的系列教程&lt;/a&gt;。也可以在微信公众号上看，比较方便。当然5分钟是指看一遍当天内容的时间，若要通过实践真正理解和掌握，5分钟远远不够，希望能坚持下去。
&lt;img src=&quot;http://shurriklab.qiniudn.com/rsbv9iwvy2lw6o3p51av7pg5jy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;blockquote&gt;
      &lt;p&gt;这些年我一直提醒自己一件事情，千万不要自己感动自己。大部分人看似的努力，不过是愚蠢导致的。什么熬夜加班到天亮，连续几天只睡几小时，多久没放假了，如果这些东西也值得夸耀，那么富土康流水线上任何一个人都比你努力多了。人难免天生有自怜的情绪，唯有时刻保持清醒，才能看清真正的价值在哪里。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;最后，马上就要持证上岗了^_^，时间过得真快，以前下班了坐地铁过去陪她走回家，现在坐我的副驾一起回家，我想，以后无论发生什么，我们也能一路走下去吧。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 06 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017-12-06/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2017-12-06/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
        
        <category>年终总结</category>
        
        
        <category>水</category>
        
      </item>
    
      <item>
        <title>动手实践Linux VLAN-每天5分钟的OpenStack(13)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#配置-vlan&quot; id=&quot;markdown-toc-配置-vlan&quot;&gt;配置 VLAN&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#配置-vm1&quot; id=&quot;markdown-toc-配置-vm1&quot;&gt;配置 VM1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#配置vm2&quot; id=&quot;markdown-toc-配置vm2&quot;&gt;配置VM2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#验证-vlan-的隔离性&quot; id=&quot;markdown-toc-验证-vlan-的隔离性&quot;&gt;验证 VLAN 的隔离性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/lwev186yhy5sif09q7cikg7hqi.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本节我们来看如何在实验环境中实施和配置如下 VLAN 网络&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/c2whl6a6g7nfjgqov1b5uqln5e.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;配置-vlan&quot;&gt;配置 VLAN&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;编辑 /etc/network/interfaces，配置 eth0.10、brvlan10、eth0.20 和 brvlan20。&lt;/p&gt;

&lt;p&gt;下面用 vmdiff 展示了对 /etc/network/interfaces 的修改&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/iydr52hykap83a27ze458gxw53.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;重启宿主机网络，ifconfig 各个网络接口&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/62wq3giwpztwqc2umaylv0b6xy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用 brctl show 查看当前 Linux Bridge 的配置。&lt;/p&gt;

&lt;p&gt;eth0.10 和 eth0.20 分别挂在 brvlan10 和 brvlan20上了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/kklzr79otpvz3gknejfuwi3rz4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在宿主机中已经提前创建好了虚机 VM1 和 VM2，现在都处于关机状态&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;配置-vm1&quot;&gt;配置 VM1&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 virt-manager 中将 VM1 的虚拟网卡挂到 brvlan10 上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/oinakjnekfls1dldpus6ryxf20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;启动 VM1&lt;/p&gt;

&lt;p&gt;查看 Bridge，发现 brvlan10 已经连接了一个 vnet0 设备&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/7gdg4qcde9g4xpanztw4738up7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过 virsh 确认这就是 VM1 的虚拟网卡。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/5atvxy96wlakmscboiiwyndrc0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;配置vm2&quot;&gt;配置VM2&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;类似的，将 VM2 的网卡挂在 brvlan20 上&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;验证-vlan-的隔离性&quot;&gt;验证 VLAN 的隔离性&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ping 测试结果： VM1 与 VM2 是不通的&lt;/p&gt;

&lt;p&gt;原因如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;VM2 向 VM1 发 Ping 包之前，需要知道 VM1 的 IP 192.168.100.10 所对应的 MAC 地址。VM2 会在网络上广播 ARP 包，其作用就是问 “谁知道 192.168.100.10 的 MAC 地址是多少？”&lt;/li&gt;
  &lt;li&gt;ARP 是二层协议，VLAN 的隔离作用使得 ARP 只能在 VLAN20 范围内广播，只有 brvlan20 和 eth0.20 能收到，VLAN10 里的设备是收不到的。VM1 无法应答 VM2 发出的ARP包。&lt;/li&gt;
  &lt;li&gt;VM2 拿不到 VM1 vnet0 的 MAC 地址，也就 Ping 不到 VM1。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux Bridge + VLAN = 虚拟交换机&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在对 KVM 的网络虚拟化做个总结：&lt;/p&gt;

&lt;p&gt;物理交换机存在多个 VLAN，每个 VLAN 拥有多个端口。&lt;/p&gt;

&lt;p&gt;同一 VLAN 端口之间可以交换转发，不同 VLAN 端口之间隔离。&lt;/p&gt;

&lt;p&gt;所以交换机其包含两层功能：交换与隔离。&lt;/p&gt;

&lt;p&gt;Linux 的 VLAN 设备实现的是隔离功能，但没有交换功能。&lt;/p&gt;

&lt;p&gt;一个 VLAN 母设备（比如 eth0）不能拥有两个相同 ID 的 VLAN 子设备，因此也就不可能出现数据交换情况。&lt;/p&gt;

&lt;p&gt;Linux Bridge 专门实现交换功能。&lt;/p&gt;

&lt;p&gt;将同一 VLAN 的子设备都挂载到一个 Bridge 上，设备之间就可以交换数据了。&lt;/p&gt;

&lt;p&gt;总结起来，Linux Bridge 加 VLAN 在功能层面完整模拟现实世界里的二层交换机。&lt;/p&gt;

&lt;p&gt;eth0 相当于虚拟交换机上的 trunk 口，允许 vlan10 和 vlan20 的数据通过&lt;/p&gt;

&lt;p&gt;eth0.10，vent0 和 brvlan10 都可以看着 vlan10 的 access 口&lt;/p&gt;

&lt;p&gt;eth0.20，vent1 和 brvlan20 都可以看着 vlan20 的 access 口&lt;/p&gt;
</description>
        <pubDate>Wed, 08 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017-11-08/%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5Linux-VLAN-%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%9A%84OpenStack(13)/</link>
        <guid isPermaLink="true">http://localhost:4000/2017-11-08/%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5Linux-VLAN-%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%9A%84OpenStack(13)/</guid>
        
        <category>虚拟化</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Linux如何实现VLAN-每天5分钟的OpenStack(12)</title>
        <description>
&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/fxhjsmemvhci8h2nm99p9hbtbu.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LAN 表示 Local Area Network，本地局域网，通常使用 Hub 和 Switch 来连接 LAN 中的计算机。&lt;/p&gt;

&lt;p&gt;一般来说，两台计算机连入同一个 Hub 或者 Switch 时，它们就在同一个 LAN 中。&lt;/p&gt;

&lt;p&gt;一个 LAN 表示一个广播域。&lt;/p&gt;

&lt;p&gt;其含义是：LAN 中的所有成员都会收到任意一个成员发出的广播包。&lt;/p&gt;

&lt;p&gt;VLAN 表示 Virtual LAN。一个带有 VLAN 功能的switch 能够将自己的端口划分出多个 LAN。&lt;/p&gt;

&lt;p&gt;计算机发出的广播包可以被同一个 LAN 中其他计算机收到，但位于其他 LAN 的计算机则无法收到。&lt;/p&gt;

&lt;p&gt;简单地说，VLAN 将一个交换机分成了多个交换机，限制了广播的范围，在二层将计算机隔离到不同的 VLAN 中。&lt;/p&gt;

&lt;p&gt;比方说，有两组机器，Group A 和 B。&lt;/p&gt;

&lt;p&gt;我们想配置成 Group A 中的机器可以相互访问，Group B 中的机器也可以相互访问，但是 A 和 B 中的机器无法互相访问。&lt;/p&gt;

&lt;p&gt;一种方法是使用两个交换机，A 和 B 分别接到一个交换机。&lt;/p&gt;

&lt;p&gt;另一种方法是使用一个带 VLAN 功能的交换机，将 A 和 B 的机器分别放到不同的 VLAN 中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;请注意，VLAN 的隔离是二层上的隔离，A 和 B 无法相互访问指的是二层广播包（比如 arp）无法跨越 VLAN 的边界。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但在三层上（比如IP）是可以通过路由器让 A 和 B 互通的。概念上一定要分清。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在的交换机几乎都是支持 VLAN 的。&lt;/p&gt;

&lt;p&gt;通常交换机的端口有两种配置模式： Access 和 Trunk。看下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/01fcumrn5amunxsqdg0bnxg808.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;了解了 VLAN 的概念之后，我们来看 KVM 虚拟化环境下是如何实现 VLAN 的。还是先看图，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/269q6xm0gpkfbw497e1flpfgmy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;eth0 是宿主机上的物理网卡，有一个命名为 eth0.10 的子设备与之相连。&lt;/p&gt;

&lt;p&gt;eth0.10 就是 VLAN 设备了，其 VLAN ID 就是 VLAN 10。&lt;/p&gt;

&lt;p&gt;eth0.10 挂在命名为 brvlan10 的 Linux Bridge 上，虚机 VM1 的虚拟网卡 vent0 也挂在 brvlan10 上。&lt;/p&gt;

&lt;p&gt;这样的配置其效果就是：&lt;/p&gt;

&lt;p&gt;宿主机用软件实现了一个交换机（当然是虚拟的），上面定义了一个 VLAN10。&lt;/p&gt;

&lt;p&gt;eth0.10，brvlan10 和 vnet0 都分别接到 VLAN10 的 Access口上。而 eth0 就是一个 Trunk 口。&lt;/p&gt;

&lt;p&gt;VM1 通过 vnet0 发出来的数据包会被打上 VLAN10 的标签。&lt;/p&gt;

&lt;p&gt;eth0.10 的作用是：定义了 VLAN10&lt;/p&gt;

&lt;p&gt;brvlan10 的作用是：Bridge 上的其他网络设备自动加入到 VLAN10 中&lt;/p&gt;

&lt;p&gt;我们再增加一个 VLAN20，见下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/rsm27anxn7hnnk9tph4371yktk.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样虚拟交换机就有两个 VLAN 了，VM1 和 VM2 分别属于 VLAN10 和 VLAN20。&lt;/p&gt;

&lt;p&gt;对于新创建的虚机，只需要将其虚拟网卡放入相应的 Bridge，就能控制其所属的 VLAN。&lt;/p&gt;

&lt;p&gt;VLAN 设备总是以母子关系出现，母子设备之间是一对多的关系。&lt;/p&gt;

&lt;p&gt;一个母设备（eth0）可以有多个子设备（eth0.10，eth0.20 ……），而一个子设备只有一个母设备。&lt;/p&gt;

&lt;p&gt;下一节我们通过实验来实践 VLAN。&lt;/p&gt;
</description>
        <pubDate>Wed, 08 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017-11-08/Linux%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0VLAN-%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%9A%84OpenStack(12)/</link>
        <guid isPermaLink="true">http://localhost:4000/2017-11-08/Linux%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0VLAN-%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%9A%84OpenStack(12)/</guid>
        
        <category>虚拟化</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>理解virbr0-每天5分钟的OpenStack(11)</title>
        <description>
&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/mirmi0r2wdu6jfu7pwhohydz8s.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;virbr0 是 KVM 默认创建的一个 Bridge，其作用是为连接其上的虚机网卡提供 NAT 访问外网的功能。&lt;/p&gt;

&lt;p&gt;virbr0 默认分配了一个IP 192.168.122.1，并为连接其上的其他虚拟网卡提供 DHCP 服务。&lt;/p&gt;

&lt;p&gt;下面我们演示如何使用 virbr0。&lt;/p&gt;

&lt;p&gt;在 virt-manager 打开 VM1 的配置界面，网卡 Source device 选择 “default”，将 VM1 的网卡挂在 virbr0 上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/v67cryj4viy664kcdp02t63vrt.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;启动 VM1，brctl show 可以查看到 vnet0 已经挂在了 virbr0 上。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# brctl show
bridge name     bridge id               STP enabled     interfaces
br0             8000.000c298decbe       no                    eth0
virbr0          8000.fe540075dd1a       yes                   vnet0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;virbr0 使用 dnsmasq 提供 DHCP 服务，可以在宿主机中查看该进程信息&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ps -elf|grep dnsmasq
5 S libvirt+  2422     1  0  80   0 -  7054 poll_s 11:26 ?        00:00:00 /usr/sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在 /var/lib/libvirt/dnsmasq/ 目录下有一个 default.leases 文件，当 VM1 成功获得 DHCP 的 IP 后，可以在该文件中查看到相应的信息&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cat /var/lib/libvirt/dnsmasq/default.leases
1441525677 52:54:00:75:dd:1a 192.168.122.6 ubuntu *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面显示 192.168.122.6 已经分配给 MAC 地址为 52:54:00:75:dd:1a 的网卡，这正是 vnet0 的 MAC。之后就可以使用该 IP 访问 VM1 了。&lt;/p&gt;

&lt;p&gt;需要说明的是，使用 NAT 的虚机 VM1 可以访问外网，但外网无法直接访问 VM1。&lt;/p&gt;

&lt;p&gt;因为 VM1 发出的网络包源地址并不是 192.168.122.6，而是被 NAT 替换为宿主机的 IP 地址了。&lt;/p&gt;

&lt;p&gt;这个与使用 br0 不一样，在 br0 的情况下，VM1 通过自己的 IP 直接与外网通信，不会经过 NAT 地址转换。&lt;/p&gt;

&lt;p&gt;下节我们讨论 vlan 在 linux bridge 中的实现&lt;/p&gt;

</description>
        <pubDate>Mon, 06 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017-11-06/%E7%90%86%E8%A7%A3virbr0-%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%9A%84OpenStack(11)/</link>
        <guid isPermaLink="true">http://localhost:4000/2017-11-06/%E7%90%86%E8%A7%A3virbr0-%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%9A%84OpenStack(11)/</guid>
        
        <category>虚拟化</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>动手实践虚拟网络-每天5分钟的OpenStack(10)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#配置-linux-bridge-br0&quot; id=&quot;markdown-toc-配置-linux-bridge-br0&quot;&gt;配置 Linux Bridge br0&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#配置-vm1&quot; id=&quot;markdown-toc-配置-vm1&quot;&gt;配置 VM1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vm2同理&quot; id=&quot;markdown-toc-vm2同理&quot;&gt;VM2同理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/og9i1qfzh56u5ecabhewxa1ct0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本节将演示如何在实验环境中实现下图所示的虚拟网络&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/n0odaculpee6zkhib5utmnz6c4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;配置-linux-bridge-br0&quot;&gt;配置 Linux Bridge br0&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;编辑 /etc/network/interfaces，配置 br0。&lt;/p&gt;

&lt;p&gt;下面用 vimdiff 展示了对 /etc/network/interfaces 的修改&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/cmlrlznw73rw9it1n72ytaj68n.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有两点需要注意：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;之前宿主机的 IP 是通过 dhcp 配置在 eth0 上的；创建 Linux Bridge 之后，IP 就必须放到 br0 上了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 br0 的配置信息中请注意最后一行 “bridge_ports eth0”，其作用就是将 eth0 挂到 br0 上&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;重启宿主机，查看 IP 配置，可以看到 IP 已经放到 br0 上了&lt;/p&gt;

&lt;p&gt;用 brctl show 查看当前 Linux Bridge 的配置。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# brctl show
bridge name     bridge id               STP enabled     interfaces
br0             8000.000c298decbe       no                    eth0
virbr0          8000.000000000000       yes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;除了 br0，大家应该注意到还有一个 virbr0 的 Bridge，而且 virbr0 上已经配置了 IP 地址 192.168.122.1。&lt;/p&gt;

&lt;p&gt;virbr0 的作用我们会在后面介绍。&lt;/p&gt;

&lt;p&gt;在宿主机中 CloudMan 已经提前创建好了虚机 VM1 和 VM2，现在都处于关机状态。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# virsh list --all
 Id    Name                           State
----------------------------------------------------
 -     VM1                            shut off
 -     VM2                            shut off
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;配置-vm1&quot;&gt;配置 VM1&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面我们在 virt-manager 中查看一下 VM1 的网卡配置（为了使大家能够熟练使用命令行工具 virsh 和图形工具 virt-manager，CloudMan 在演示的时候会同时用到它们，两个工具都很重要）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/yswaw21r7esfke2mbk07u5uufe.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到虚拟网卡的 source device 我们选择的是 br0&lt;/p&gt;

&lt;p&gt;下面我们启动 VM1，看会发生什么&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# brctl show

bridge name     bridge id               STP enabled     interfaces
br0             8000.000c298decbe       no                    eth0
                                                                                  vnet0
virbr0          8000.000000000000       yes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;brctl show 告诉我们 br0 下面添加了一个 vnet0 设备，通过 virsh 确认这就是VM1的虚拟网卡。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# virsh domiflist VM1
Interface  Type       Source     Model       MAC
-------------------------------------------------------
vnet0      bridge     br0        rtl8139     52:54:00:75:dd:1a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外，在 VM1 中虚拟网卡是 eth0，并不是 vnet0。&lt;/p&gt;

&lt;p&gt;vent0 是该虚拟网卡在宿主机中对应的设备名称，其类型是 TAP 设备，这里需要注意一下。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;vm2同理&quot;&gt;VM2同理&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过 br0 这个 Linux Bridge，我们实现了 VM1、VM2、宿主机和外网这四者之间的数据通信。&lt;/p&gt;

&lt;p&gt;下节我们讨论 virbr0&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017-11-06/%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C-%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%9A%84OpenStack(10)/</link>
        <guid isPermaLink="true">http://localhost:4000/2017-11-06/%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C-%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%9A%84OpenStack(10)/</guid>
        
        <category>虚拟化</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>KVM网络虚拟化基础-每天5分钟的OpenStack(9)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#linux-bridge-基本概念&quot; id=&quot;markdown-toc-linux-bridge-基本概念&quot;&gt;Linux Bridge 基本概念&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/kg8z02ffcldcaryhnt0pwlgsw0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;网络虚拟化是虚拟化技术中最复杂的部分，学习难度最大。 但因为网络是虚拟化中非常重要的资源，所以再硬的骨头也必须要把它啃下来。&lt;/p&gt;

&lt;p&gt;为了让大家对虚拟化网络的复杂程度有一个直观的认识，请看下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/gi9e6acegclerg57pybpdnxxhi.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是 OpenStack 官网上给出的计算节点（可以理解为 KVM 的宿主机）虚拟网络的逻辑图，上面的网络设备很多，层次也很复杂。&lt;/p&gt;

&lt;p&gt;我第一次看到这张图，也着实被吓了一跳。&lt;/p&gt;

&lt;p&gt;不过大家也不要怕，万丈高楼从地起，虚拟网络再复杂，也是由一些基础的组件构成的。只要我们将这些基础组件的概念和它们之间的逻辑关系搞清楚了，就能深刻理解虚拟网络的架构，那么云环境下的虚拟化网络也就不在话下了。&lt;/p&gt;

&lt;p&gt;下面我们来学习网络虚拟化中最重要的两个东西：Linux Bridge 和 VLAN&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;linux-bridge-基本概念&quot;&gt;Linux Bridge 基本概念&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;假设宿主机有 1 块与外网连接的物理网卡 eth0，上面跑了 1 个虚机 VM1，现在有个问题是： 如何让 VM1 能够访问外网？&lt;/p&gt;

&lt;p&gt;至少有两种方案&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将物理网卡eth0直接分配给VM1，但随之带来的问题很多： 宿主机就没有网卡，无法访问了； 新的虚机，比如 VM2 也没有网卡。 下面看推荐的方案&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;给 VM1 分配一个虚拟网卡 vnet0，通过 Linux Bridge  br0 将 eth0 和 vnet0 连接起来，如下图所示&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/s8m2p6j0zy2xz0cswr68t107ii.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Linux Bridge 是 Linux 上用来做 TCP/IP 二层协议交换的设备，其功能大家可以简单的理解为是一个二层交换机或者 Hub。多个网络设备可以连接到同一个 Linux Bridge，当某个设备收到数据包时，Linux Bridge 会将数据转发给其他设备。&lt;/p&gt;

&lt;p&gt;在上面这个例子中，当有数据到达 eth0 时，br0 会将数据转发给 vnet0，这样 VM1 就能接收到来自外网的数据；&lt;/p&gt;

&lt;p&gt;反过来，VM1 发送数据给 vnet0，br0 也会将数据转发到 eth0，从而实现了 VM1 与外网的通信。&lt;/p&gt;

&lt;p&gt;现在我们增加一个虚机 VM2，如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://shurriklab.qiniudn.com/7rqpib71nxzmeinfl67p8386ht.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;VM2 的虚拟网卡 vnet1 也连接到了 br0 上。&lt;/p&gt;

&lt;p&gt;现在 VM1 和 VM2 之间可以通信，同时 VM1 和 VM2 也都可以与外网通信。&lt;/p&gt;

&lt;p&gt;有了上面的基础知识，下一节将演示如何在实验环境中实现这套虚拟网络。&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017-11-05/KVM%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%9A%84OpenStack(9)/</link>
        <guid isPermaLink="true">http://localhost:4000/2017-11-05/KVM%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%9A%84OpenStack(9)/</guid>
        
        <category>虚拟化</category>
        
        
        <category>Linux</category>
        
      </item>
    
  </channel>
</rss>
